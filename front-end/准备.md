# 响应式布局 
原理：一套代码，去适应多端的页面布局，而不是单独的两套
实现：
* 媒体查询
给不同屏幕的大小编写不同的样式来实现响应式的布局
缺点：
对于复杂的响应式设计，可能需要编写大量的媒体查询代码，增加了代码的复杂性和维护难度。
只能基于一些预定义的条件进行判断，对于一些特殊的需求可能无法满足
```css
@media screen and (max-device-width:960px){     body{background:red;} }
```
* rem
1rem=html根元素标签的fontsize
* vw、vh
因为 100vw = 100视图窗宽度 ，100vh = 100 视图窗高度，那么按照750的设计稿100vw就是750.那么1vw就是7.5px
* flex 弹性布局
* 容器查询 
更有灵活性，但是兼容性差

# 路由
[阿里P7：你了解路由吗？年后被迫跳槽，其中种种一言难尽，于是投递简历，虽然有了年前尝试积累，但年前毕竟不是真正的跳槽。由 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904113990270989?searchId=20230719194727C905D849125CD77F0962#heading-0)


# 居中
1. **使用 Flex 布局**：
    
    - 将父元素设置为 Flex 容器，并使用`justify-content: center;`和`align-items: center;`来使子元素在水平和垂直方向上居中。
2. **使用 Grid 布局**：
    
    - 将父元素设置为 Grid 容器，并使用`place-items: center;`来使子元素在网格中居中。
3. **使用绝对定位和负边距**：
    
    - 将子元素设置为绝对定位，并使用`top: 50%; left: 50%; transform: translate(-50%, -50%);`来使其在父元素中居中。
4. **使用文本居中**：
    
    - 对于文本元素，可以使用`text-align: center;`来使其在父元素中水平居中。
5. **使用 margin 自动**：
    
    - 如果子元素的宽度已知，可以将其左右 margin 设置为`auto`，以使其在父元素中水平居中。

# js判断数据类型
## typeof
只能判断基础类型和引用类型
判断 null结果是object
```js
console.log(typeof 123); // "number"
console.log(typeof "hello"); // "string"
console.log(typeof true); // "boolean"
console.log(typeof undefined); // "undefined"
console.log(typeof null); // "object"
console.log(typeof {}); // "object"
console.log(typeof []); // "object"
console.log(typeof function(){}); // "function"
console.log(typeof null); // "object"
console.log(typeof NaN); // "number"
console.log(typeof document.all); // "undefined"

```
## construct
- `constructor` 指向创建该实例对象的构造函数
```js
const arr = [1, 2, 3];
console.log(arr.constructor === Array) // true

const obj = {name: "云牧", age: 18};
console.log(obj.constructor === Object) // true


String.prototype.constructor = function fn() {
  return {};
}

// constructor 可以被改写
console.log("云牧".constructor) // [Function: fn]

```
## instanceof

- 语法：`obj instanceof Type`
- 功能：判断 `obj` 是不是 `Type` 类的实例，只可用来判断引用数据
- 实现思路： `Type` 的原型对象是否是 `obj` 的原型链上的某个对象
- 注意：右操作数必须是函数或者 class
```js
const arr = [1, 2, 3]
console.log(arr instanceof Array) // true
console.log(arr instanceof Object) // true

const obj = { name: "云牧", age: 18 }
console.log(obj instanceof Object) // true
console.log(obj instanceof Array) // false

```


## Object.prototype.toString
- 利用函数动态 this 的特性
```js
Object.prototype.toString.call(123); // "[object Number]"
Object.prototype.toString.call("hello"); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function(){}); // "[object Function]"
// 注意的是，Object.prototype.toString.call 方法返回的字符串格式为 "[object 类型]"

// 封装
function typeOf(data) {
  return Object.prototype.toString.call(data).slice(8, -1);
}

// 测试
console.log(typeOf(1)); // Number
console.log(typeOf("1")); // String
console.log(typeOf(true)); // Boolean
console.log(typeOf(null)); // Null
console.log(typeOf(undefined)); // Undefined
console.log(typeOf(Symbol(1))); // Symbol
console.log(typeOf({})); // Object
console.log(typeOf([])); // Array
console.log(typeOf(function () {})); // Function
console.log(typeOf(new Date())); // Date
console.log(typeOf(new RegExp())); // RegExp

```
# 动画
## JS动画
	* **setTimeout** / **setInterval** / **requestAnimationFrame**
`setTimeout/setInterval` 无法与浏览器每帧绘制保持同步，所以可能会存在卡顿、丢帧、抖动的现象，导致动画体验不如 CSS3 动画。所以才有了 **与浏览器的绘制帧同步** 的原生 API `requestAnimationFrame`，以取代 `setTimeout` 和 `setInterval` 实现动画。

	* **Web Animations API**
## CSS动画
	* **CSS Transition**
CSS 过渡，属于**补间动画**，即设置关键帧的初始状态，然后在另一个关键帧改变这个状态，比如大小、颜色、透明度等，浏览器将自动根据二者之间帧的值创建的动画。无法自动执行。会在元素的属性值发生变化时平滑地过渡到新的值。
```css
  div {
    opacity: 1;
  }
  
  div:hover {
    opacity: 0.5;
    transition: opacity, 3s;
  }
  

```
	* **CSS Animation**
CSS 动画，可以理解是 `CSS Transition` 的加强版，它既可以实现 **补间动画** 的动画效果，也可以使其以 **逐帧动画** 的方式进行绘制。可以自动执行
```css
  @keyframes slidein {
    from {
      transform: translateX(0%);
    }

    to {
      transform: translateX(100%);
    }
  }

  /* 等效于下面 @keyframes 规则的定义 */

  @keyframes slidein {
    0% {
      transform: translateX(0%);
    }

    100% {
      transform: translateX(100%);
    }
  }


```

> css动画都可以通过js事件去监听

用CSS3动画替代JS模拟动画的好处：

1. 不占用JS主线程；
    
2. 可以利用硬件加速；
    
3. 浏览器可对动画做优化（元素不可见时不动画减少对FPS影响）

# 自定义hooks  
组合hooks
实现过的hooks，useKeepScroll
复用逻辑


# option compositon（vue2和vue3的对比） 
## 为什么要有组合式 API？
### 更好的逻辑复用
### 更灵活的代码组织
### TS支持更好
### 更小的生产包体积



# proxy defineProperty对比
Vue3.x改用`Proxy`替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。


## defineProperty
```js
let person = {}
let personName = 'lihua'

//在person对象上添加属性namep,值为personName
Object.defineProperty(person, 'namep', {
    //但是默认是不可枚举的(for in打印打印不出来)，可：enumerable: true
    //默认不可以修改，可：wirtable：true
    //默认不可以删除，可：configurable：true
    get: function () {
        console.log('触发了get方法')
        return personName
    },
    set: function (val) {
        console.log('触发了set方法')
        personName = val
    }
})

//当读取person对象的namp属性时，触发get方法
console.log(person.namep)

//当修改personName时，重新访问person.namep发现修改成功
personName = 'liming'
console.log(person.namep)

// 对person.namep进行修改，触发set方法
person.namep = 'huahua'
console.log(person.namep)

\

```
当监听数组的时候，`push`方法给数组增加的元素，set方法是监听不到的。通过索引访问或者修改数组中已经存在的元素，是可以出发get和set的，但是对于通过push、unshift增加的元素，会增加一个索引，这种情况需要手动初始化，新增加的元素才能被监听到。另外， 通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法。

在Vue2.x中，通过重写Array原型上的方法解决了这个问题

## Proxy
```js
//定义一个需要代理的对象
let person = {
    age: 0,
    school: 'xdu'
}
//定义handler对象
let hander = {
    get(obj, key) {
        console.log('触发了get')
        // 如果对象里有这个属性，就返回属性值，如果没有，就返回默认值66
        return key in obj ? obj[key] : 66
    },
    set(obj, key, val) {
        console.log('触发了set')
        obj[key] = val
        return true
    }
}
//把handler对象传入Proxy
let proxyObj = new Proxy(person, hander)

// 测试get能否拦截成功
console.log(proxyObj.school)//输出：触发了get xdu
console.log(proxyObj.name)//输出：触发了get 66

// 测试set能否拦截成功
proxyObj.age = 18 // 输出：触发了set
console.log(proxyObj.age)//输出： 触发了set 18

```

Proxy代理的是整个对象，而不是对象的某个特定属性，不需要我们通过遍历来逐个进行数据绑定。
值得注意的是:之前我们在使用Object.defineProperty()给对象添加一个属性之后，我们对对象属性的读写操作仍然在对象本身。  
但是一旦使用Proxy，如果想要读写操作生效，我们就要对Proxy的实例对象`proxyObj`进行操作。

在上面使用Object.defineProperty的时候，我们遇到的问题有：

 
1. 一次只能对一个属性进行监听，需要遍历来对所有属性监听。这个我们在上面已经解决了。  
2. 在遇到一个对象的属性还是一个对象的情况下，需要递归监听。  
3. 对于对象的新增属性，需要手动监听  
4. 对于数组通过push、unshift方法增加的元素，也无法监听
数组push会触发两次proxy的set方法，因为会更新数组元素和length属性

# 跨域
跨域问题其实就是浏览器的同源策略所导致的。它用于限制一个[origin](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2F%25E6%25BA%2590 "https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90")的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
协议、域名、端口一致。才能算是同源

为什么需要跨域？
限制不同源的请求
限制DOM操作
> 可以在 http 返回头 添加`X-Frame-Options: SAMEORIGIN` 防止被别人添加至 iframe。

## 解决跨域
跨域资源共享([CORS](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FCORS "https://developer.mozilla.org/zh-CN/docs/Glossary/CORS")) 是一种机制，它使用额外的 [HTTP](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FHTTP "https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP") 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器**「不同的域、协议或端口」**请求一个资源时，资源会发起一个**「跨域 HTTP 请求」**。
CORS中请求会分为简单请求和复杂请求。
### 简单请求
简单请求不会触发 [CORS 预检请求](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FAccess_control_CORS%23Preflighted_requests "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests")
满足
下面条件的请求是简单请求
情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)

- [`GET`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FGET "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET")
- [`HEAD`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FHEAD "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD")
- [`POST`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FPOST "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST")

情况二: 人为设置以下集合外的请求头

- [`Accept`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept")
- [`Accept-Language`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept-Language "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language")
- [`Content-Language`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Language "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language")
- [`Content-Type`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Type "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type") （需要注意额外的限制）
- `DPR`
- `Downlink`
- `Save-Data`
- `Viewport-Width`
- `Width`

情况三：`Content-Type`的值仅限于下列三者之一：(例如 application/json 为非简单请求)

- `text/plain`
- `multipart/form-data`
- `application/x-www-form-urlencoded`
情况四:

请求中的任意[`XMLHttpRequestUpload`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload "https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload") 对象均没有注册任何事件监听器；[`XMLHttpRequestUpload`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload "https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload") 对象可以使用 [`XMLHttpRequest.upload`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest%2Fupload "https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload") 属性访问。

情况五:

请求中没有使用 [`ReadableStream`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FReadableStream "https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream") 对象。

### 复杂请求

非简单请求的都是复杂请求
如果请求是复杂请求，在发送复杂请求之前，会先发送一个**预请求**，此时作为服务端，也需要返回"预回应"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。
**预请求以OPTIONS形式发送**，当中同样包含域，并且还包含了两项CORS特有的内容：
> Access-Control-Request-Method – 该项内容是实际请求的种类，可以是GET、POST之类的简单请求，也可以是PUT、DELETE等等。  
Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。

## 解决方法

1.  服务器在响应头加上对应的header
 ```js
 app.use(async (ctx, next) => {  
  ctx.set("Access-Control-Allow-Origin", ctx.headers.origin);  
  ctx.set("Access-Control-Allow-Credentials", true);  
  ctx.set("Access-Control-Request-Method", "PUT,POST,GET,DELETE,OPTIONS");  
  ctx.set(  
    "Access-Control-Allow-Headers",  
    "Origin, X-Requested-With, Content-Type, Accept, cc"  
  );  
  if (ctx.method === "OPTIONS") {  
    ctx.status = 204;  
    return;  
  }  
  await next();  
});
```

这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 `withCredentials` 来进行传递 `cookie`.
```js
// 原生 xml 的设置方式
var xhr = new XMLHttpRequest();xhr.withCredentials = true;// axios 设置方式axios.defaults.withCredentials = true;

```

2. Node正向代理
利用服务端请求不会跨域的特性，让接口和当前站点同域。

3. 配置构建工具的proxy
一般仅限于开发模式中，因为开发才会启动着webpack，vite之类的构建工具，和正向代理一个原理

4. JSONP
`JSONP` 主要就是利用了 `script` 标签没有跨域限制的这个特性来完成的。

**「使用限制」**

仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。

```js
//后端
const Koa = require("koa");
const fs = require("fs");
const app = new Koa();
app.use(async (ctx, next) => {
    if (ctx.path === "/api/jsonp") {
        const { cb, msg } = ctx.query;
        ctx.body = `${cb}(${JSON.stringify({ msg })})`;
        return;
    }
});
app.listen(8080);

```

```html
//前端

<script type="text /javascript">  window.jsonpCallback = function (res) { console.log(res); };</script>
<script  src="http: //localhost:8080/api/jsonp?msg=hello&cb=jsonpCallback"  type="text/javascript"></script>
```

5. websocket
这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制.

6. postMessage
postMessage能忽略跨域进行跨域页面通信
```html
<iframe  src="http: //localhost:8080"  frameborder="0"   id="iframe"   onload="load()"></iframe>
<script>  function load() { iframe.contentWindow.postMessage("秋风的笔记", "http://localhost:8080"); window.onmessage = e => { console.log(e.data); }; }</script>
```

```html
<div>hello</div><script>  window.onmessage = e => {    console.log(e.data); // 秋风的笔记    e.source.postMessage(e.data, e.origin);  };</script>

```
7.  document.domain + Iframe
**「该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式」**。 只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。
```html
<body>  
  helloa  
  <iframe  
    src="http://b.test.com/b.html"  
    frameborder="0"  
    onload="load()"  
    id="frame"  
  ></iframe>  
  <script>    document.domain = "test.com";  
    function load() {  
      console.log(frame.contentWindow.a);  
    }  </script>  
</body>
```

```html
<body>  
  hellob  
  <script>    document.domain = "test.com";  
    var a = 100;  </script>  
</body>
```


事件机制
# 事件循环
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240828001446.png)
JavaScript的任务分为两种`同步`和`异步`：

- **同步任务：** 在主线程上排队执行的任务，只有一个任务执行完毕，才能执行下一个任务，
- **异步任务：** 不进入主线程，而是放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到执行栈然后主线程执行调用栈的任务。
在`JavaScript`中，任务被分为两种，一种宏任务（`MacroTask`）也叫`Task`，一种叫微任务（`MicroTask`）。

### MacroTask（宏任务）

- `script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见[`MDN`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetImmediate "https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate")）、`I/O`、`UI Rendering`。

### MicroTask（微任务）

- `Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver`（具体使用方式查看[这里](https://link.juejin.cn/?target=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fdom%2Fmutationobserver.html "http://javascript.ruanyifeng.com/dom/mutationobserver.html")）
`Javascript` 有一个 `main thread` 主线程和 `call-stack` 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。

### JS调用栈

JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。

### 同步任务和异步任务

`Javascript`单线程任务被分为**同步任务**和**异步任务**，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。


![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240828001926.png)
执行栈在执行完**同步任务**后，查看**执行栈**是否为空，如果执行栈为空，就会去检查**微任务**(`microTask`)队列是否为空，如果为空的话，就执行`Task`（宏任务），否则就一次性执行完所有微任务。  
每次单个**宏任务**执行完毕后，检查**微任务**(`microTask`)队列是否为空，如果不为空的话，会按照**先入先**出的规则全部执行完**微任务**(`microTask`)后，设置**微任务**(`microTask`)队列为`null`，然后再执行**宏任务**，如此循环。


# Vue

# 生命周期
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829210941.png)


![[Vue3生命周期.excalidraw|675]]
# nextTick
[全局 API：常规 | Vue.js (vuejs.org)](https://cn.vuejs.org/api/general.html#nexttick)
当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。
`nextTick()` 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise。

```vue
<script setup>
import { ref, nextTick } from 'vue'

const count = ref(0)

async function increment() {
  count.value++

  // DOM 还未更新
  console.log(document.getElementById('counter').textContent) // 0

  await nextTick()
  // DOM 此时已经更新
  console.log(document.getElementById('counter').textContent) // 1
}
</script>

<template>
  <button id="counter" @click="increment">{{ count }}</button>
</template>
```

## vue-router

SPA中的路由一般有两种方式去实现hash模式和hisotry模式，反正两种模式的特点都是url变化但是不会去刷新页面。
### hash router

`hash` 模式是一种把前端路由的路径用井号 `#` 拼接在真实 `url` 后面的模式。当井号 `#` 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 `onhashchange` 事件。
#### 特点
- `hash` 可以改变 `url` ，但是不会触发页面重新加载（hash的改变是记录在 `window.history` 中），即不会刷新页面。也就是说，所有页面的跳转都是在客户端进行操作。因此，这并不算是一次 `http` 请求，所以这种模式不利于 `SEO` 优化。`hash` 只能修改 `#` 后面的部分，所以只能跳转到与当前 `url` 同文档的 `url` 。
- `hash` 通过 `window.onhashchange` 的方式，来监听 `hash` 的改变，借此实现无刷新跳转的功能。
- - `hash` 永远不会提交到 `server` 端（可以理解为只在前端自生自灭）。
#### 缺点
1. 地址栏中携带#，不美观
2. 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL
3. 设置的新值必须与原来不一样才会触发hashchange事件，并将记录添加到栈中
```js
window.addEventListener("load", this.updateView.bind(this)); // hash模式 路由修改时 浏览器会触发hashchange事件 调用更新视图函数 
window.addEventListener("hashchange", this.updateView.bind(this));
```


### history router
`history API` 是 `H5` 提供的新特性，允许开发者**直接更改前端路由**，即更新浏览器 `URL` 地址而**不重新发起请求**基于HTML5新增的pushState()和replaceState()两个api，以及浏览器的popstate事件，地址变化时，浏览器不会刷新页面，通过window.location.pathname找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容。

#### 特点
1. 没有#，更加美观
2. pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL
3. pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中
4. pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中
5. pushState() 可额外设置 title 属性供后续使用
6. 浏览器的进后退能触发浏览器的popstate事件，获取window.location.pathname来控制页面的变化

#### 缺点
- 使用 `history` 模式时，在对当前的页面进行刷新时，此时浏览器会重新发起请求。如果 `nginx` 没有匹配得到当前的 `url` ，就会出现 `404` 的页面。
- 而对于 `hash` 模式来说， 它虽然看着是改变了 `url` ，但不会被包括在 `http` 请求中。所以，它算是被用来指导浏览器的动作，并不影响服务器端。因此，改变 `hash` 并没有真正地改变 `url` ，所以页面路径还是之前的路径， `nginx` 也就不会拦截。
- 因此，在使用 `history` 模式时，需要**通过服务端来允许地址可访问**，如果没有设置，就很容易导致出现 `404` 的局面。



宏任务 微任务

状态管理vuex和piana的区别

# 组件通信
## props
## emits
## expose/ref

## attrs

## provide/inject

## 状态管理




vue和react的区别

js动画和css动画 

# requestAnimationFrame
raf在JS代码之后，重绘回流之前执行。
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/Snipaste_2024-08-28_09-29-14.png)

- 使得动画更加流畅，防止动画失帧 requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率
    
- 资源节能(Cpu、内存等)
    
    1. 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量
    2. requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销
应用场景：
* 大数据渲染
* 复杂动画
# requestIdleCallback
requestIdleCallback 会在网页渲染完成后，CPU 空闲时执行，不一定每一帧都执行。

requestIdleCallback 不适合执行 DOM 操作，因为修改了 DOM 之后下一帧不一定会触发修改。
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/Snipaste_2024-08-28_09-29-14.png)
一帧有六个步骤：
- 处理用户的交互
- JS 解析执行
- 帧开始。窗口尺寸变更，页面滚动等的处理
- requestAnimationFrame(rAF)
- 布局
- 绘制

> 上面的步骤执行完之后如果还有空余的时间，会去执行requestIdleCallback里注册的任务。
> 如果是60hz的屏幕就是16.66ms     1000/60 。每帧16.66ms的时间

requestIdleCallback 可用于一些低优先级的场景，以代替 setTimeout 。例如发送统计数据。
  **Promise 也不建议在这里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 `requestIdleCallback` 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。**
  

# 隐藏元素的方法
## display:none
不会在DOM树上出现
## visibility:hidden
隐藏元素，但元素所占的空间仍然保留，其他元素不会受到影响。
## opacity:0
使元素透明，但元素仍然存在于页面上，并且可以与其他元素交互。
## position:absolute 和 z-index设为负数
设置位置到页面之外


缓存

回流重会 渲染机制？

防抖节流

虚拟DOM优缺点

# 页面生命周期
- `DOMContentLoaded` —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 `<img>` 和样式表之类的外部资源可能尚未加载完成。
- `load` —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。
- `beforeunload/unload` —— 当用户正在离开页面时。

# 项目性能优化
## 启动缓存
所谓的前端缓存，其实就是http缓存，通过（强缓存/协商缓存）等方式让计算机直接从缓存中读取静态资源，从而实现_节约宽带_，_提高响应速度_，_减少服务器压力_等优化。

## 开启gzip压缩
常规情况下前端部署所需要的dist包中会有一些静态文件（如js，css，图片文件）。这些静态文件会在项目初始化后续某个动作下被加载。出于体积大小的不同，加载速度也不一样。有些文件比较大，加载所需时间相对较长，针对文件加载慢的情况。

我们可以采用一些压缩方案，让这些静态文件的体积尽量变小。这样，就可以相对的_节约宽带_，而因为这些文件的变小，对这些的静态文件的_加载的速度也会得到提升_，客户端也可以尽快响应给用户一个良好的体验。

gzip有着比zip更优秀的压缩算法，可以有效的减少文件的大小。

## 使用函数节流和防抖

节流和防抖都是将我们大量重复多余的操作进行合并，以达到_减少客户端或服务端压力_，_提高运算速度_，_减少http请求_等效果。
### 节流
频繁触发一个事件时候，每隔一段时间，函数只会执行一次。
场景：
滚动条滚动事件，dom的拖拽事件等
### 防抖
当触发一个时间后的n秒内，如果该事件没有被第二次触发，则执行。否，则重新开始计时。
场景：
搜索框的搜索事件，按钮提交

## 异步加载文件

浏览器在下载和解析script文件的时候会停止html的解析和 CSSOM 的构建。

所以，在以前我们通常喜欢把< script >标签放在html的最后面。

当然，不想将< script >标签放在后面又不想让script的下载和解析影响html的渲染，也有方案。在script标签中加上_defer_属性即可。

script标签的defer属性可以让script异步加载并在DOM构建完成和CSS渲染完毕之后再执行
注意：有多种执行外部脚本的方法：
如果async="async'":脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）
如果不使用async且defe="defer”:脚本将在页面完成解析时执行
如果既不使用async也不使用defer::在浏览器继续解析页面之前，立即读取并执行脚本
  
## 减少重排和重绘
重排和重绘是浏览器中相对比较耗时的动作。尤其是重排。

_重绘不一定会引起重排。重排一定会导致重绘。_

浏览器上我们所能看见的元素。当它们的位置发生改变的时候，并不是流动的。而是先被擦除，再重新生成。这就像画画，当画上的某一个单位需要改变位置，我们无法直接把这个单位直接进行移动，只能先将其擦除，然后在指定的位置重新画一个。

元素改变位置，浏览器会先在指定位置上构建该元素的dom（重排）(注意这里没有渲染)，然后在对该元素进行渲染（比如background,color）（重绘）。

元素在位置上的改变属于重排，非位置上的改变基本属于重绘（不绝对）。

比如一个原本红色背景的div，如果仅仅改变背景为蓝色的话，那么只会触发重绘，并不会触发重排。（因为位置没有变，只有CSS改变）

  **重绘触发场景**

- background的改变
- color的改变
- visibility:hidden
- css3的translate
- color, border-style, border-radius, visibility, text-decoration, background, background-image, background-position,  background-repeat, background-size，outline-color, outline-style, outline-width, box-shadow
- ...

**重排的触发场景**

- 删除或者新增一个节点元素
- 元素位置的改变，比如float,position,overflow,display等等
- 元素尺寸的改变，比如margin,padding,height,width等等
- 初始化构建DOM树的时候
- 窗口尺寸的变化 也就是resize事件发生的时候
- 填充内容的改变（内容撑大了某一个节点，内容改变，包含它的节点大小自然跟随调整。）
- 读取某一个元素的时候，比如offsetLeft，offsetTop，offsetHeight，offsetWidth,　clientTop，clientLeft，clientWidth，clientHeight,　scrollTop，scrollLeft，scrollWidth，scrollHeight,　width，height等等
- ...

使用部分CSS属性来优化性能
在 GPU 渲染的过程中，一些元素会因为符合了某些规则，而被提升为独立的层（黄色边框部分），一旦独立出来，就不会影响其它 DOM 的布局，所以我们可以利用这些规则，将经常变换的 DOM 主动提升到独立的层，那么在浏览器的一帧运行中，就可以减少 Layout 和 Paint 的时间了。
哪些规则能让浏览器主动帮我们创建独立的层呢？

1. 3D 或者透视变换（perspective，transform） 的 CSS 属性。
2. 使用加速视频解码的 video 元素。
3. 拥有 3D（WebGL） 上下文或者加速 2D 上下文的 canvas 元素。
4. 混合插件（Flash)。
5. 对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素。
6. 拥有加速 CSS 过滤器的元素。
7. 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)。
8. 元素有一个兄弟元素在复合图层渲染，并且该兄弟元素的 z-index 较小，那这个元素也会被应用到复合图层。
#### 开启 GPU 加速

CSS 中的以下几个属性能触发硬件加速：

1. transform
2. opacity
3. filter
4. will-change


## 使用服务端渲染
如果使用服务端渲染（SSR）的话，首先_首屏加载速度会有显著的提升_（因为SSE只需要加载首页一个页面）。并且_对SEO也很友好_。

当然它也有弊端：页面数据更容易被爬。服务器压力会变大。


## 图片优化
图片压缩tiny-png，或者更换webp格式图片或者avif格式图片

## 使用CDN资源

 ## 使用HTTP2
 



## 合并请求
_为了减少请求时间，为了减小服务器压力_。ajax请求并不是没有成本的。每次请求都需要进行TCP的_三次握手_和_四次挥手，解析报文_等一系列的过程，这些过程都需要时间去执行。并且，浏览器在同一域名下的请求并发数有限制，_同一域名下同一个请求只能并发一个，不同类型请求（比如GET/POST）并发个数基本在4-6个之间_。假设当前浏览器的并发请求有6个。那么第7个请求就需要等前6个请求中任意一个完成以后才可以从任务队列中被拉出去执行。_所以，合并请求可以在一定程度上减少资源响应时间，给用户带来更好的使用体验。_

  合并请求的基本方案

1. 使用精灵图（合并静态图片资源请求）
2. 合理合并get请求,在适当的情况下，我们可以将一些可以合并的get请求合并为一个

## 事件委托
将事件挂载到父元素上面去
_事件委托适用场景：列表数据和瀑布流数据等需要大量绑定相同功能的函数的场景。_

## 使用CSS动画完成动画
一些简单的，需要手动绘制的动画，在CSS可以完成的情况下，_尽量避免使用JS完成动画_。

使用CSS完成动画的好处是：

1. 不占用主线程（js是需要占用的）
2. 可以利用硬件加速
3. 在不可见时动画不会持续执行

## 使用懒加载
对于一些不必要立即显示的节点，我们可以采用懒加载技术。在需要使用到的时候，再去加载该文件（组件），以减少不必要的内存占用和页面负载。

## 使用骨架屏

## absolute脱离文档流优化css性能，这样元素改变就不会大面积的重排了


## webworker（大量数据运算）
webworker是独立的线程，不会与主线程冲突
实现主线程与复杂计运算线程的分离，从而减轻了因大量计算而造成UI阻塞的情况

# vue性能优化
## 组件懒加载
## 使用computed缓存结果

## 用v-show 而不是 v-if





# HTTP1-2 性能优化
？？

# Observer API

## IntersectionObserver
**IntersectionObserver 可以监听一个元素和可视区域相交部分的比例，然后在可视比例达到某个阈值的时候触发回调。**


## MutationObserver
**MutationObserver 可以监听对元素的属性的修改、对它的子节点的增删改。**


## ResizeObserver
窗口我们可以用 addEventListener 监听 resize 事件，那元素呢？

**元素可以用 ResizeObserver 监听大小的改变，当 width、height 被修改时会触发回调。**



## PerformanceObserver
浏览器提供了 performance 的 api 用于记录一些时间点、某个时间段、资源加载的耗时等。

我们希望记录了 performance 那就马上上报，可是怎么知道啥时候会记录 performance 数据呢？

用 PeformanceObserver。

  
## ReportingObserver

**ReportingObserver 可以监听过时的 api、浏览器干预等报告等的打印，在回调里上报，这些是错误监听无法监听到但对了解网页运行情况很有用的数据。**


监听用户的交互行为，我们会用 addEventListener 来监听 click、mousedown、keydown、input 等事件，但对于元素的变化、performance 的记录、浏览器干预行为这些不是用户交互的事件就要用 XxxObserver 的 api 了。

浏览器提供了这 5 种 Observer：

- IntersectionObserver：监听元素可见性变化，常用来做元素显示的数据采集、图片的懒加载
- MutationObserver：监听元素属性和子节点变化，比如可以用来做去不掉的水印
- ResizeObserver：监听元素大小变化

还有两个与元素无关的：

- PerformanceObserver：监听 performance 记录的行为，来上报数据
- ReportingObserver：监听过时的 api、浏览器的一些干预行为的报告，可以让我们更全面的了解网页 app 的运行情况

这些 api 相比 addEventListener 添加的交互事件来说用的比较少，但是在特定场景下都是很有用的。

  

作者：zxg_神说要有光  
链接：https://juejin.cn/post/7064557881492209678  
来源：稀土掘金  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 原型链
[Blog/articles/深入系列文章/JavaScript深入之从原型到原型链.md at master · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/blob/master/articles/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE.md)



# 闭包
当一个内部函数可以访问其外部函数的变量时，便形成了闭包
闭包的实现，实际上是利用了`JavaScript`中作用域链的概念，简单理解就是：在`JavaScript`中，如果在某个作用域下访问某个变量的时候，如果不存在，就一直向外层寻找，直到在全局作用域下找到对应的变量为止，这里就形成了所谓的作用域链。

## 闭包的特性

1. 闭包可以访问到父级函数的变量
2. 访问到父级函数的变量不会销毁
## 作用
- **实现共有变量**：在模块化开发中，闭包可以用来创建私有变量并暴露有限的公共接口，实现数据的封装和隔离。
- **做缓存**：利用闭包可以存储计算结果，避免重复计算，提高程序效率。
- **封装模块，防止全局变量污染**：通过闭包封装变量和函数，可以有效减少全局作用域的污染，保持代码的整洁和可维护性。

  
## 缺点
内容可能得不到释放，引发内存泄漏
# this

# vite相关面试题
`vite`开发环境依赖`esbuild`进行预构建，生产环境则依赖`rollup`进行打包，并且充分利用了现代浏览器的特性，比如`http2`、`ES module`，`vite`是站在众多巨人肩膀上的一个产物， 类似`webpack + webpack-dev-server`的结合体，是一个非常棒的前端项目的构建工具。

  绝大多数现代浏览器都已经支持`ES module`了， 我们只需要在`<script>`标签中添加`type="module"`，就可以使用`ES module`了。
在`<script type="module">`中，浏览器遇到内部的import引用时，会自动发起http请求，去加载对应的模块。

vite也正是利用了`ES module`这个特性，使用vite运行项目时，首先会用`esbuild`进行预构建，将所有模块转换为`es module`，不需要对我们整个项目进行编译打包，而是在浏览器需要加载某个模块时，拦截浏览器发出的请求，根据请求进行`按需编译`，然后返回给浏览器。
esbuild使用的是go语言编写的，可以充分利用多核CPU的优势，所以vite开发环境下的`预构建`与`按需编译`速度，都是非常快的
。

## http2
  vite充分利用了http2可以并发请求的优势，这也是速度快的一个主要原因。 接下来，我们了解一下**http2**的来龙去脉。

在之前http1的时候，浏览器对同一个域名的请求，是有并发限制的，一般为6个，如果并发请求6个以上，就会造成阻塞问题，所以在http1的时代，我们要减少打包产物的文件数量，减少并发请求，来提高项目的加载速度。

2015年以后，http2出现了，他可以并发发送多个请求，不会出现http1的并发限制。这时候，将打包产物分成多个小模块，并行去加载，反而会更快。

vite也充分利用了这一优势，对项目资源进行了合理的拆分，访问项目时，同时加载多个模块，来提升项目访问速度。

  
webpack热更新会重新打包项目，即使有缓存机制，也还是长时间
vite项目中，监听到文件变更后，会用`websocket`通知浏览器，重新发起新的请求，只对该模块进行重新编译，然后进行替换。

并且基于`es module`的特性，vite利用浏览器的缓存策略，针对源码模块（我们自己写的代码）做了`协商缓存`处理，针对依赖模块（第三方库）做了`强缓存`处理，这样我们项目的访问的速度也就更快了。

## 生产环境

Rollup 是一款 `ES Module` 打包器， 从作用上来看，`Rollup` 与 `Webpack` 非常类似。不过相比于 `Webpack`，`Rollup`要小巧的多，打包生成的文件更小。 因为小巧，自然在这种特定的打包环境下，`Rollup`的打包速度也要比 `Webpack` 快很多。

vite正是基于`es module`的特性实现的，所以使用rollup要更合适一些。

**vite生产环境下，为什么不用esbuild打包呢？**

尽管esbuild的打包速度比rollup更快，但 Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容，rollup插件api与基础建设更加完善，所以在生产环境vite使用rollup打包会更稳定一些。

如果后面esbuild基础建设与生态更加完善后，esbuild还是更有优势的。

所以使用vite可能会带来开发环境与生产环境打包结果不一致的问题。


webpack很多东西要自己搭建，比如：`跨域`、`代码压缩`、`代码分割`、`css预处理器的代码转换`、`样式兼容性`、`vue/react代码解析`、`图片压缩`、`代码热更新`、`es降级`、`ts转换`等等。vite对这些常用功能都做了内置支持。




# CMS
背景：每次运营有活动都需要开发去开发新的页面

## PDF文件生成

# SEO优化

使用语义化标签
在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。
img 添加 alt 属性，用 h1 标签去写内容关键字

meta标签

**A. Keywords(关键词，很重要)**  
说明：规定一个逗号分隔的关键词列表（告诉搜索引擎页面是与什么相关的）。


`例如：<meta name="keywords" content="掘金,稀土,Vue.js,前端面试题,Kotlin,ReactNative,Python">`

**B. description(网站内容描述，很重要)**  
说明：规定页面的描述。搜索引擎会把这个描述显示在搜索结果中。

`例如：<meta name="description" content="掘金是面向全球中文开发者的技术内容分享与交流平台。我们通过技术文章、沸点、课程、直播等产品和服务，打造一个激发开发者创作灵感，激励开发者沉淀分享，陪伴开发者成长的综合类技术社区。">`

**C. author**  
说明：作者的名字


`例如：<meta name="author" content="Hege Refsnes">`

**D. generator**  
说明：代表说明网站的采用的什么软件制作。


`例如：<meta name="generator" content="Hege Refsnes">`

**E. theme-color**  
说明：代表页面显示设计的建议颜色。


`例如：<meta name="theme-color" content="#4285f4" />`

**1.2 http- equiv**

http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容。  
meta标签的http-equiv属性语法格式是： `<meta http-equiv="参数"content="参数变量值">；`  
其中http-equiv属性主要有以下几种参数：

## 确保页面性能

## sitemap站点地图
## 使用HTTPS

# es6 和后面新的api

[ES6 完全使用手册此外还要注意这里不一定就是正式进入规范的语法。 1. let 和 const 在我们开发的时候，可能 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903726201700365?searchId=2024082815002430731E303B990D645B53)

[2.8万字总结！！ES6到ES12常用新特性！ES是ECMAScript的缩写，也就是JavaScript的标准化规范。 - 掘金 (juejin.cn)](https://juejin.cn/post/7272176270808137783#heading-32)

# Vue和React区别
### 相同点

1. **虚拟DOM**：
    
    - Vue和React都采用了虚拟DOM技术。它们都会创建一个虚拟的DOM树，并与真实DOM树进行对比，只更新有变化的部分，从而大大提高了页面的渲染性能。
2. **组件化**：
    
    - 两者都支持组件化开发，将UI拆分为可复用的组件，有助于构建大型和可维护的应用程序。
    - 两者都支持父子组件之间的数据传递（props），并且都强调单向数据流（尽管Vue通过v-model等机制实现了双向数据绑定，但本质上也是单向数据流的一种实现）。
3. **数据驱动视图**：
    
    - Vue和React都是数据驱动视图的框架，当数据发生变化时，视图会自动更新。
4. **服务端渲染**：
    
    - 两者都支持服务端渲染（SSR），有助于改善SEO和首屏加载速度。
5. **构建工具**：
    
    - Vue和React都有自己的构建工具，可以快速搭建开发环境。Vue对应的是vue-cli，而React则可以使用Create React App (CRA)。
### 区别

1. **实现原理**：
    
    - Vue采用组件响应式思想，通过getter/setter以及一些函数的劫持，能精确知道数据的变化，并触发相应的视图更新。
    - React则采用函数式组件思想，通过diff算法比较新旧虚拟DOM的差异，然后更新真实DOM。React 16还引入了Fiber架构，将DOM树微观化为链表，提高了diff算法的效率。
2. **设计结构**：
    
    - Vue使用的是可变数据，数据由data属性在Vue对象中进行管理。
    - React更强调数据的不可变性，通过setState()方法更新状态。
3. **数据流**：
    
    - Vue通过v-model等机制实现了双向数据绑定，使得数据模型和视图之间的同步更加直接。
    - React则采用单向数据流，通过props将数据从父组件传递到子组件，并通过回调函数或Context等方式实现子组件到父组件的数据传递。
4. **模板语法**：
    
    - Vue鼓励使用HTML模板语法，写起来更接近于常规的HTML结构，同时支持在模板中直接编写CSS和JavaScript。
    - React则推荐使用JSX语法，将HTML和CSS都写进JavaScript中，实现了“all in js”的理念。
5. **状态管理**：
    
    - Vue的状态管理可以通过Vuex等库实现，但Vue的核心也提供了一定程度的状态管理能力。
    - React的状态管理则更多依赖于Redux等第三方库。
6. **框架本质**：
    
    - Vue是一个渐进式框架，旨在降低前端开发的门槛，让更多的人能够更快地上手开发。它使用了MVVM框架，由MVC框架发展而来。
    - React则是一个前端组件化框架，由后端组件化发展而来。它更关注于UI的开发，提供了丰富的UI组件和API。
7. **学习曲线**：
    
    - Vue被认为对新手友好，其文档清晰且框架设计较为直观。
    - React由于其更“裸露”的性质和丰富的生态系统，可能需要更多的学习时间。

## Hooks
Vue中的hooks是通过响应式实现的，所以在任何地方都能使用

React中hooks是通过单链表实现的，挂载在Fiber书。根据声明hooks顺序去构建单链表。如果在条件语句中声明，会破坏hooks链表顺序
* useState
* useReducer
* useContext
* useRef
* useEffect
* useLayoutEffect
* useMemo
* useTransition
* useDeferredValue


# 网络
## TCP
### 流量控制
### 拥塞控制
目的就是**避免「发送方」的数据填满整个网络。**
为了在「发送方」调节所要发送数据的量，定义了一个叫做「**拥塞窗口**」的概念。
**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。
发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。
拥塞窗口`cwnd`变化的规则：
* 只要网络中没有出现拥塞，cwnd就增大
* 如果网络中出现了拥塞，cwnd就减小
> 那么怎么知道当前网络是否出现了拥塞呢？


只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞。**
拥塞控制主要是四个算法：
* 慢启动
* 拥塞避免
* 拥塞发生
* 快速恢复
#### 慢启动
**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829232227.png)
有一个叫慢启动门限 `ssthresh` （slow start threshold）状态变量。
- 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
- 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」。
#### 拥塞避免
当拥塞窗口 `cwnd` 「超过」慢启动门限 `ssthresh` 就会进入拥塞避免算法。
一般来说 `ssthresh` 的大小是 `65535` 字节。
那么进入拥塞避免算法后，它的规则是：**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**
接上前面的慢启动的栗子，现假定 `ssthresh` 为 `8`：
当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 `MSS` 大小的数据，变成了**线性增长。**
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829233322.png)
拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。当触发了重传机制，也就进入了「拥塞发生算法」。

#### 拥塞发生
当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：
- 超时重传
- 快速重传

> 当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：
- `ssthresh` 设为 `cwnd/2`，
- `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）

![](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829233620.png)

>  发生快速重传的拥塞发生算法

还有更好的方式，前面我们讲过「快速重传算法」。还有更好的方式，前面我们讲过「快速重传算法」。TCP 认为这种情况不严重，因为大部分没丢只丢了一小部分，则 `ssthresh` 和 `cwnd` 变化如下：
- `cwnd = cwnd/2` ，也就是设置为原来的一半;
- `ssthresh = cwnd`;
- 进入快速恢复算法

#### 快速恢复
快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 `RTO` 超时那么强烈。
正如前面所说，进入快速恢复之前，`cwnd` 和 `ssthresh` 已被更新了：
- `cwnd = cwnd/2` ，也就是设置为原来的一半;
- `ssthresh = cwnd`;
然后，进入快速恢复算法如下：
- 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的 ACK，那么 cwnd 增加 1；
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829234012.png)


# 介绍项目+项目难点亮点+怎么解决

## 电子保卡
背景：在过去，患者在做了植入器械之后，厂商会出具实体保卡给患者，供患者去医院随访的时候出示，走线下流程就代表着可能会丢失保卡或者邮寄时间过长。这个系统是用来取代线下的流程，患者直接在微信公众号注册登记信息之后，后台会进行匹配，匹配成功之后，就会去发放电子保卡。患者就可以在公众号端看到自己的电子保卡。

### 组件保留滚动
难点：平常我们使用KeepAlive标签去在页面切换的时候保留上一个页面组件。包括滚动进度。但是如果滚动条不是在页面上，而是在某一个元素上面，KeepAlive就无法做到保留元素的滚动进度。

解决方法：通过查阅资料可以自己通过hooks实现
主要利用生命周期函数deactivated和activated。在deactivated中把元素的滚动位置记录下来，在activated中还原元素的滚动位置。把这两个生命周期函数抽成hooks。这样就可以在需要使用的组件里面去引入。

### 数据迁移
难点：
* 数据源来自多方
* 表结构改动过大
* 数据量大
#### 解决方法




## 代收缴费用系统
一个用来代替第三方公司去缴纳水电费用的系统。主要是和其他银行系统进行交互。因为系统老旧，所以没有通过http请求，都是通过txt文件上传下载去进行系统交互。这个系统主要就是各种的txt文件和PDF文件生成。PDF文件用来内部使用签名之类的，txt文件用来和其他系统交互。

难点：
应用是一个低代码应用，但是文件的生成是通过JS去实现的， 通过JS去开发一个生成PDF文件的组件，然后在应用中使用。主要技术是用HTMLtoCanvas，然后CanvasToPDF。主要遇到了两个难点。
生成的PDF会有文字重叠的情况：
因为低代码应用为了适应在任何分辨率和高宽的场景下，都保持同样的布局，所以使用了transform进行缩放。生成文件所用的PDF也在transform的影响之内，所以导致生成的PDF会文字重叠。
解决方法：把HTML元素移除到transform的元素之外。

在一个PDF里面生成了太多页导致报错，输入长度超过限制
通过pnpm patch去改源码库，使用arraybuffer替代string传入解决长度限制
[Fix Invalid String Length When Saving PDF #1724 by shiina-mash1ro · Pull Request #3625 · parallax/jsPDF (github.com)](https://github.com/parallax/jsPDF/pull/3625)

###  文字重叠
因为把节点渲染在受transform影响的节点之内导致的
解决：通过查阅资料之后，发现需要把节点挂载到transform节点之外，比如body旁边


# CMS
运营部门每隔一段时间需要出活动页，活动页基本上都是一样的东西，只是图案文本等元素不对。每次都要开发去重新修改代码去适配太过麻烦。所以开发出了一套CMS去给运营使用，运营只需要去配置文本，图片等素材，即可创建新的活动网页。

难点：服务端读取配置内容后渲染页面后生成对应的HTML文件。在不使用SSR的情况下，进行服务端渲染。查阅文档之后发现Vite有一个SSG的支持。基于此支持开发出了CMS内容。自己实现了useClient或者useServer之类的hook，可以分别在客户端和服务端上运行对应的函数hooks。