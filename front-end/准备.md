响应式布局 
原理：一套代码，去适应多端的页面布局，而不是单独的两套
实现：
* 媒体查询
给不同屏幕的大小编写不同的样式来实现响应式的布局
缺点：
对于复杂的响应式设计，可能需要编写大量的媒体查询代码，增加了代码的复杂性和维护难度。
只能基于一些预定义的条件进行判断，对于一些特殊的需求可能无法满足
```css
@media screen and (max-device-width:960px){     body{background:red;} }
```
* rem
1rem=html根元素标签的fontsize
* vw、vh
因为 100vw = 100视图窗宽度 ，100vh = 100 视图窗高度，那么按照750的设计稿100vw就是750.那么1vw就是7.5px
* flex 弹性布局
* 容器查询 
更有灵活性，但是兼容性差



# 动画
* JS动画
	* **setTimeout** / **setInterval** / **requestAnimationFrame**
`setTimeout/setInterval` 无法与浏览器每帧绘制保持同步，所以可能会存在卡顿、丢帧、抖动的现象，导致动画体验不如 CSS3 动画。所以才有了 **与浏览器的绘制帧同步** 的原生 API `requestAnimationFrame`，以取代 `setTimeout` 和 `setInterval` 实现动画。

	* **Web Animations API**
* CSS动画
	* **CSS Transition**
CSS 过渡，属于**补间动画**，即设置关键帧的初始状态，然后在另一个关键帧改变这个状态，比如大小、颜色、透明度等，浏览器将自动根据二者之间帧的值创建的动画。无法自动执行。会在元素的属性值发生变化时平滑地过渡到新的值。
```css
  div {
    opacity: 1;
  }
  
  div:hover {
    opacity: 0.5;
    transition: opacity, 3s;
  }
  

```
	* **CSS Animation**
CSS 动画，可以理解是 `CSS Transition` 的加强版，它既可以实现 **补间动画** 的动画效果，也可以使其以 **逐帧动画** 的方式进行绘制。可以自动执行
```css
  @keyframes slidein {
    from {
      transform: translateX(0%);
    }

    to {
      transform: translateX(100%);
    }
  }

  /* 等效于下面 @keyframes 规则的定义 */

  @keyframes slidein {
    0% {
      transform: translateX(0%);
    }

    100% {
      transform: translateX(100%);
    }
  }


```

> css动画都可以通过js事件去监听

# 自定义hooks  
组合hooks
实现过的hooks，useKeepScroll
复用逻辑


# option compositon（vue2和vue3的对比） 
## 为什么要有组合式 API？
### 更好的逻辑复用
### 更灵活的代码组织
### TS支持更好
### 更小的生产包体积



# proxy defineProperty对比
Vue3.x改用`Proxy`替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。


## defineProperty
```js
let person = {}
let personName = 'lihua'

//在person对象上添加属性namep,值为personName
Object.defineProperty(person, 'namep', {
    //但是默认是不可枚举的(for in打印打印不出来)，可：enumerable: true
    //默认不可以修改，可：wirtable：true
    //默认不可以删除，可：configurable：true
    get: function () {
        console.log('触发了get方法')
        return personName
    },
    set: function (val) {
        console.log('触发了set方法')
        personName = val
    }
})

//当读取person对象的namp属性时，触发get方法
console.log(person.namep)

//当修改personName时，重新访问person.namep发现修改成功
personName = 'liming'
console.log(person.namep)

// 对person.namep进行修改，触发set方法
person.namep = 'huahua'
console.log(person.namep)

\

```
当监听数组的时候，`push`方法给数组增加的元素，set方法是监听不到的。通过索引访问或者修改数组中已经存在的元素，是可以出发get和set的，但是对于通过push、unshift增加的元素，会增加一个索引，这种情况需要手动初始化，新增加的元素才能被监听到。另外， 通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法。

在Vue2.x中，通过重写Array原型上的方法解决了这个问题

## Proxy
```js
//定义一个需要代理的对象
let person = {
    age: 0,
    school: 'xdu'
}
//定义handler对象
let hander = {
    get(obj, key) {
        console.log('触发了get')
        // 如果对象里有这个属性，就返回属性值，如果没有，就返回默认值66
        return key in obj ? obj[key] : 66
    },
    set(obj, key, val) {
        console.log('触发了set')
        obj[key] = val
        return true
    }
}
//把handler对象传入Proxy
let proxyObj = new Proxy(person, hander)

// 测试get能否拦截成功
console.log(proxyObj.school)//输出：触发了get xdu
console.log(proxyObj.name)//输出：触发了get 66

// 测试set能否拦截成功
proxyObj.age = 18 // 输出：触发了set
console.log(proxyObj.age)//输出： 触发了set 18

```

Proxy代理的是整个对象，而不是对象的某个特定属性，不需要我们通过遍历来逐个进行数据绑定。
值得注意的是:之前我们在使用Object.defineProperty()给对象添加一个属性之后，我们对对象属性的读写操作仍然在对象本身。  
但是一旦使用Proxy，如果想要读写操作生效，我们就要对Proxy的实例对象`proxyObj`进行操作。

在上面使用Object.defineProperty的时候，我们遇到的问题有：

 
1. 一次只能对一个属性进行监听，需要遍历来对所有属性监听。这个我们在上面已经解决了。  
2. 在遇到一个对象的属性还是一个对象的情况下，需要递归监听。  
3. 对于对象的新增属性，需要手动监听  
4. 对于数组通过push、unshift方法增加的元素，也无法监听
数组push会触发两次proxy的set方法，因为会更新数组元素和length属性

# 跨域
跨域问题其实就是浏览器的同源策略所导致的。它用于限制一个[origin](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2F%25E6%25BA%2590 "https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90")的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
协议、域名、端口一致。才能算是同源

为什么需要跨域？
限制不同源的请求
限制DOM操作
> 可以在 http 返回头 添加`X-Frame-Options: SAMEORIGIN` 防止被别人添加至 iframe。

## 解决跨域
跨域资源共享([CORS](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FCORS "https://developer.mozilla.org/zh-CN/docs/Glossary/CORS")) 是一种机制，它使用额外的 [HTTP](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FHTTP "https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP") 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器**「不同的域、协议或端口」**请求一个资源时，资源会发起一个**「跨域 HTTP 请求」**。
CORS中请求会分为简单请求和复杂请求。
### 简单请求
简单请求不会触发 [CORS 预检请求](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FAccess_control_CORS%23Preflighted_requests "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests")
满足
下面条件的请求是简单请求
情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)

- [`GET`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FGET "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET")
- [`HEAD`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FHEAD "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD")
- [`POST`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FPOST "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST")

情况二: 人为设置以下集合外的请求头

- [`Accept`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept")
- [`Accept-Language`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept-Language "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language")
- [`Content-Language`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Language "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language")
- [`Content-Type`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Type "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type") （需要注意额外的限制）
- `DPR`
- `Downlink`
- `Save-Data`
- `Viewport-Width`
- `Width`

情况三：`Content-Type`的值仅限于下列三者之一：(例如 application/json 为非简单请求)

- `text/plain`
- `multipart/form-data`
- `application/x-www-form-urlencoded`
情况四:

请求中的任意[`XMLHttpRequestUpload`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload "https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload") 对象均没有注册任何事件监听器；[`XMLHttpRequestUpload`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload "https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload") 对象可以使用 [`XMLHttpRequest.upload`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest%2Fupload "https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload") 属性访问。

情况五:

请求中没有使用 [`ReadableStream`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FReadableStream "https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream") 对象。

### 复杂请求

非简单请求的都是复杂请求
如果请求是复杂请求，在发送复杂请求之前，会先发送一个**预请求**，此时作为服务端，也需要返回"预回应"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。
**预请求以OPTIONS形式发送**，当中同样包含域，并且还包含了两项CORS特有的内容：
> Access-Control-Request-Method – 该项内容是实际请求的种类，可以是GET、POST之类的简单请求，也可以是PUT、DELETE等等。  
Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。

## 解决方法

1.  服务器在响应头加上对应的header
 ```js
 app.use(async (ctx, next) => {  
  ctx.set("Access-Control-Allow-Origin", ctx.headers.origin);  
  ctx.set("Access-Control-Allow-Credentials", true);  
  ctx.set("Access-Control-Request-Method", "PUT,POST,GET,DELETE,OPTIONS");  
  ctx.set(  
    "Access-Control-Allow-Headers",  
    "Origin, X-Requested-With, Content-Type, Accept, cc"  
  );  
  if (ctx.method === "OPTIONS") {  
    ctx.status = 204;  
    return;  
  }  
  await next();  
});
```

这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 `withCredentials` 来进行传递 `cookie`.
```js
// 原生 xml 的设置方式
var xhr = new XMLHttpRequest();xhr.withCredentials = true;// axios 设置方式axios.defaults.withCredentials = true;

```

2. Node正向代理
利用服务端请求不会跨域的特性，让接口和当前站点同域。

3. 配置构建工具的proxy
一般仅限于开发模式中，因为开发才会启动着webpack，vite之类的构建工具，和正向代理一个原理

4. JSONP
`JSONP` 主要就是利用了 `script` 标签没有跨域限制的这个特性来完成的。

**「使用限制」**

仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。

```js
//后端
const Koa = require("koa");
const fs = require("fs");
const app = new Koa();
app.use(async (ctx, next) => {
    if (ctx.path === "/api/jsonp") {
        const { cb, msg } = ctx.query;
        ctx.body = `${cb}(${JSON.stringify({ msg })})`;
        return;
    }
});
app.listen(8080);

```

```html
//前端

<script type="text /javascript">  window.jsonpCallback = function (res) { console.log(res); };</script>
<script  src="http: //localhost:8080/api/jsonp?msg=hello&cb=jsonpCallback"  type="text/javascript"></script>
```

5. websocket
这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制.

6. postMessage
postMessage能忽略跨域进行跨域页面通信
```html
<iframe  src="http: //localhost:8080"  frameborder="0"   id="iframe"   onload="load()"></iframe>
<script>  function load() { iframe.contentWindow.postMessage("秋风的笔记", "http://localhost:8080"); window.onmessage = e => { console.log(e.data); }; }</script>
```

```html
<div>hello</div><script>  window.onmessage = e => {    console.log(e.data); // 秋风的笔记    e.source.postMessage(e.data, e.origin);  };</script>

```
7.  document.domain + Iframe
**「该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式」**。 只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。
```html
<body>  
  helloa  
  <iframe  
    src="http://b.test.com/b.html"  
    frameborder="0"  
    onload="load()"  
    id="frame"  
  ></iframe>  
  <script>    document.domain = "test.com";  
    function load() {  
      console.log(frame.contentWindow.a);  
    }  </script>  
</body>
```

```html
<body>  
  hellob  
  <script>    document.domain = "test.com";  
    var a = 100;  </script>  
</body>
```


事件机制
# 事件循环
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240828001446.png)
JavaScript的任务分为两种`同步`和`异步`：

- **同步任务：** 在主线程上排队执行的任务，只有一个任务执行完毕，才能执行下一个任务，
- **异步任务：** 不进入主线程，而是放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到执行栈然后主线程执行调用栈的任务。
在`JavaScript`中，任务被分为两种，一种宏任务（`MacroTask`）也叫`Task`，一种叫微任务（`MicroTask`）。

### MacroTask（宏任务）

- `script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见[`MDN`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetImmediate "https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate")）、`I/O`、`UI Rendering`。

### MicroTask（微任务）

- `Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver`（具体使用方式查看[这里](https://link.juejin.cn/?target=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fdom%2Fmutationobserver.html "http://javascript.ruanyifeng.com/dom/mutationobserver.html")）
`Javascript` 有一个 `main thread` 主线程和 `call-stack` 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。

### JS调用栈

JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。

### 同步任务和异步任务

`Javascript`单线程任务被分为**同步任务**和**异步任务**，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。


![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240828001926.png)
执行栈在执行完**同步任务**后，查看**执行栈**是否为空，如果执行栈为空，就会去检查**微任务**(`microTask`)队列是否为空，如果为空的话，就执行`Task`（宏任务），否则就一次性执行完所有微任务。  
每次单个**宏任务**执行完毕后，检查**微任务**(`microTask`)队列是否为空，如果不为空的话，会按照**先入先**出的规则全部执行完**微任务**(`microTask`)后，设置**微任务**(`microTask`)队列为`null`，然后再执行**宏任务**，如此循环。



# vue-router
## hash router

## history router



宏任务 微任务

状态管理vuex和piana的区别

# 组件通信
## props
## emits
## expose/ref

## attrs

## provide/inject

## 状态管理




vue和react的区别

js动画和css动画 

# requestAnimationFrame
raf在JS代码之后，重绘回流之前执行。
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/Snipaste_2024-08-28_09-29-14.png)

- 使得动画更加流畅，防止动画失帧 requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率
    
- 资源节能(Cpu、内存等)
    
    1. 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量
    2. requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销
应用场景：
* 大数据渲染
* 复杂动画
# requestIdleCallback
requestIdleCallback 会在网页渲染完成后，CPU 空闲时执行，不一定每一帧都执行。

requestIdleCallback 不适合执行 DOM 操作，因为修改了 DOM 之后下一帧不一定会触发修改。
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/Snipaste_2024-08-28_09-29-14.png)
一帧有六个步骤：
- 处理用户的交互
- JS 解析执行
- 帧开始。窗口尺寸变更，页面滚动等的处理
- requestAnimationFrame(rAF)
- 布局
- 绘制

> 上面的步骤执行完之后如果还有空余的时间，会去执行requestIdleCallback里注册的任务。
> 如果是60hz的屏幕就是16.66ms     1000/60 。每帧16.66ms的时间

requestIdleCallback 可用于一些低优先级的场景，以代替 setTimeout 。例如发送统计数据。
  **Promise 也不建议在这里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 `requestIdleCallback` 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。**
  

# 隐藏元素的方法
## display:none
不会在DOM树上出现
## visibility:hidden
隐藏元素，但元素所占的空间仍然保留，其他元素不会受到影响。
## opacity:0
使元素透明，但元素仍然存在于页面上，并且可以与其他元素交互。
## position:absolute 和 z-index设为负数
设置位置到页面之外


缓存

回流重会 渲染机制？

防抖节流

虚拟DOM优缺点

# 页面生命周期
- `DOMContentLoaded` —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 `<img>` 和样式表之类的外部资源可能尚未加载完成。
- `load` —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。
- `beforeunload/unload` —— 当用户正在离开页面时。

# 项目性能优化
## 启动缓存
所谓的前端缓存，其实就是http缓存，通过（强缓存/协商缓存）等方式让计算机直接从缓存中读取静态资源，从而实现_节约宽带_，_提高响应速度_，_减少服务器压力_等优化。

## 开启gzip压缩
常规情况下前端部署所需要的dist包中会有一些静态文件（如js，css，图片文件）。这些静态文件会在项目初始化后续某个动作下被加载。出于体积大小的不同，加载速度也不一样。有些文件比较大，加载所需时间相对较长，针对文件加载慢的情况。

我们可以采用一些压缩方案，让这些静态文件的体积尽量变小。这样，就可以相对的_节约宽带_，而因为这些文件的变小，对这些的静态文件的_加载的速度也会得到提升_，客户端也可以尽快响应给用户一个良好的体验。

gzip有着比zip更优秀的压缩算法，可以有效的减少文件的大小。

## 使用函数节流和防抖

节流和防抖都是将我们大量重复多余的操作进行合并，以达到_减少客户端或服务端压力_，_提高运算速度_，_减少http请求_等效果。
### 节流
频繁触发一个事件时候，每隔一段时间，函数只会执行一次。
场景：
滚动条滚动事件，dom的拖拽事件等
### 防抖
当触发一个时间后的n秒内，如果该事件没有被第二次触发，则执行。否，则重新开始计时。
场景：
搜索框的搜索事件，按钮提交

## 异步加载文件

浏览器在下载和解析script文件的时候会停止html的解析和 CSSOM 的构建。

所以，在以前我们通常喜欢把< script >标签放在html的最后面。

当然，不想将< script >标签放在后面又不想让script的下载和解析影响html的渲染，也有方案。在script标签中加上_defer_属性即可。

script标签的defer属性可以让script异步加载并在DOM构建完成和CSS渲染完毕之后再执行
注意：有多种执行外部脚本的方法：
如果async="async'":脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）
如果不使用async且defe="defer”:脚本将在页面完成解析时执行
如果既不使用async也不使用defer::在浏览器继续解析页面之前，立即读取并执行脚本
  
## 减少重排和重绘
重排和重绘是浏览器中相对比较耗时的动作。尤其是重排。

_重绘不一定会引起重排。重排一定会导致重绘。_

浏览器上我们所能看见的元素。当它们的位置发生改变的时候，并不是流动的。而是先被擦除，再重新生成。这就像画画，当画上的某一个单位需要改变位置，我们无法直接把这个单位直接进行移动，只能先将其擦除，然后在指定的位置重新画一个。

元素改变位置，浏览器会先在指定位置上构建该元素的dom（重排）(注意这里没有渲染)，然后在对该元素进行渲染（比如background,color）（重绘）。

元素在位置上的改变属于重排，非位置上的改变基本属于重绘（不绝对）。

比如一个原本红色背景的div，如果仅仅改变背景为蓝色的话，那么只会触发重绘，并不会触发重排。（因为位置没有变，只有CSS改变）

  **重绘触发场景**

- background的改变
- color的改变
- visibility:hidden
- css3的translate
- color, border-style, border-radius, visibility, text-decoration, background, background-image, background-position,  background-repeat, background-size，outline-color, outline-style, outline-width, box-shadow
- ...

**重排的触发场景**

- 删除或者新增一个节点元素
- 元素位置的改变，比如float,position,overflow,display等等
- 元素尺寸的改变，比如margin,padding,height,width等等
- 初始化构建DOM树的时候
- 窗口尺寸的变化 也就是resize事件发生的时候
- 填充内容的改变（内容撑大了某一个节点，内容改变，包含它的节点大小自然跟随调整。）
- 读取某一个元素的时候，比如offsetLeft，offsetTop，offsetHeight，offsetWidth,　clientTop，clientLeft，clientWidth，clientHeight,　scrollTop，scrollLeft，scrollWidth，scrollHeight,　width，height等等
- ...

  

## 使用服务端渲染
如果使用服务端渲染（SSR）的话，首先_首屏加载速度会有显著的提升_（因为SSE只需要加载首页一个页面）。并且_对SEO也很友好_。

当然它也有弊端：页面数据更容易被爬。服务器压力会变大。


## 图片优化
图片压缩tiny-png，或者更换webp格式图片或者avif格式图片

## 使用CDN资源

 ## 使用HTTP2
 



## 合并请求
_为了减少请求时间，为了减小服务器压力_。ajax请求并不是没有成本的。每次请求都需要进行TCP的_三次握手_和_四次挥手，解析报文_等一系列的过程，这些过程都需要时间去执行。并且，浏览器在同一域名下的请求并发数有限制，_同一域名下同一个请求只能并发一个，不同类型请求（比如GET/POST）并发个数基本在4-6个之间_。假设当前浏览器的并发请求有6个。那么第7个请求就需要等前6个请求中任意一个完成以后才可以从任务队列中被拉出去执行。_所以，合并请求可以在一定程度上减少资源响应时间，给用户带来更好的使用体验。_

  合并请求的基本方案

1. 使用精灵图（合并静态图片资源请求）
2. 合理合并get请求,在适当的情况下，我们可以将一些可以合并的get请求合并为一个

## 事件委托
将事件挂载到父元素上面去
_事件委托适用场景：列表数据和瀑布流数据等需要大量绑定相同功能的函数的场景。_

## 使用CSS动画完成动画
一些简单的，需要手动绘制的动画，在CSS可以完成的情况下，_尽量避免使用JS完成动画_。

使用CSS完成动画的好处是：

1. 不占用主线程（js是需要占用的）
2. 可以利用硬件加速
3. 在不可见时动画不会持续执行

## 使用懒加载
对于一些不必要立即显示的节点，我们可以采用懒加载技术。在需要使用到的时候，再去加载该文件（组件），以减少不必要的内存占用和页面负载。

## 使用骨架屏

## absolute脱离文档流优化css性能，这样元素改变就不会大面积的重排了


## webworker（大量数据运算）
webworker是独立的线程，不会与主线程冲突
实现主线程与复杂计运算线程的分离，从而减轻了因大量计算而造成UI阻塞的情况

# vue性能优化
## 组件懒加载
## 使用computed缓存结果

## 用v-show 而不是 v-if





# HTTP1-2 性能优化
？？

# Observer API

## IntersectionObserver
**IntersectionObserver 可以监听一个元素和可视区域相交部分的比例，然后在可视比例达到某个阈值的时候触发回调。**


## MutationObserver
**MutationObserver 可以监听对元素的属性的修改、对它的子节点的增删改。**


## ResizeObserver
窗口我们可以用 addEventListener 监听 resize 事件，那元素呢？

**元素可以用 ResizeObserver 监听大小的改变，当 width、height 被修改时会触发回调。**



## PerformanceObserver
浏览器提供了 performance 的 api 用于记录一些时间点、某个时间段、资源加载的耗时等。

我们希望记录了 performance 那就马上上报，可是怎么知道啥时候会记录 performance 数据呢？

用 PeformanceObserver。

  
## ReportingObserver

**ReportingObserver 可以监听过时的 api、浏览器干预等报告等的打印，在回调里上报，这些是错误监听无法监听到但对了解网页运行情况很有用的数据。**


监听用户的交互行为，我们会用 addEventListener 来监听 click、mousedown、keydown、input 等事件，但对于元素的变化、performance 的记录、浏览器干预行为这些不是用户交互的事件就要用 XxxObserver 的 api 了。

浏览器提供了这 5 种 Observer：

- IntersectionObserver：监听元素可见性变化，常用来做元素显示的数据采集、图片的懒加载
- MutationObserver：监听元素属性和子节点变化，比如可以用来做去不掉的水印
- ResizeObserver：监听元素大小变化

还有两个与元素无关的：

- PerformanceObserver：监听 performance 记录的行为，来上报数据
- ReportingObserver：监听过时的 api、浏览器的一些干预行为的报告，可以让我们更全面的了解网页 app 的运行情况

这些 api 相比 addEventListener 添加的交互事件来说用的比较少，但是在特定场景下都是很有用的。

  

作者：zxg_神说要有光  
链接：https://juejin.cn/post/7064557881492209678  
来源：稀土掘金  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 原型链
[Blog/articles/深入系列文章/JavaScript深入之从原型到原型链.md at master · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/blob/master/articles/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE.md)



# 闭包
当一个内部函数可以访问其外部函数的变量时，便形成了闭包
闭包的实现，实际上是利用了`JavaScript`中作用域链的概念，简单理解就是：在`JavaScript`中，如果在某个作用域下访问某个变量的时候，如果不存在，就一直向外层寻找，直到在全局作用域下找到对应的变量为止，这里就形成了所谓的作用域链。

## 闭包的特性

1. 闭包可以访问到父级函数的变量
2. 访问到父级函数的变量不会销毁
## 作用
- **实现共有变量**：在模块化开发中，闭包可以用来创建私有变量并暴露有限的公共接口，实现数据的封装和隔离。
- **做缓存**：利用闭包可以存储计算结果，避免重复计算，提高程序效率。
- **封装模块，防止全局变量污染**：通过闭包封装变量和函数，可以有效减少全局作用域的污染，保持代码的整洁和可维护性。

  
## 缺点
内容可能得不到释放，引发内存泄漏
# this

# vite相关面试题
`vite`开发环境依赖`esbuild`进行预构建，生产环境则依赖`rollup`进行打包，并且充分利用了现代浏览器的特性，比如`http2`、`ES module`，`vite`是站在众多巨人肩膀上的一个产物， 类似`webpack + webpack-dev-server`的结合体，是一个非常棒的前端项目的构建工具。

  绝大多数现代浏览器都已经支持`ES module`了， 我们只需要在`<script>`标签中添加`type="module"`，就可以使用`ES module`了。
在`<script type="module">`中，浏览器遇到内部的import引用时，会自动发起http请求，去加载对应的模块。

vite也正是利用了`ES module`这个特性，使用vite运行项目时，首先会用`esbuild`进行预构建，将所有模块转换为`es module`，不需要对我们整个项目进行编译打包，而是在浏览器需要加载某个模块时，拦截浏览器发出的请求，根据请求进行`按需编译`，然后返回给浏览器。
esbuild使用的是go语言编写的，可以充分利用多核CPU的优势，所以vite开发环境下的`预构建`与`按需编译`速度，都是非常快的
。

## http2
  vite充分利用了http2可以并发请求的优势，这也是速度快的一个主要原因。 接下来，我们了解一下**http2**的来龙去脉。

在之前http1的时候，浏览器对同一个域名的请求，是有并发限制的，一般为6个，如果并发请求6个以上，就会造成阻塞问题，所以在http1的时代，我们要减少打包产物的文件数量，减少并发请求，来提高项目的加载速度。

2015年以后，http2出现了，他可以并发发送多个请求，不会出现http1的并发限制。这时候，将打包产物分成多个小模块，并行去加载，反而会更快。

vite也充分利用了这一优势，对项目资源进行了合理的拆分，访问项目时，同时加载多个模块，来提升项目访问速度。

  
webpack热更新会重新打包项目，即使有缓存机制，也还是长时间
vite项目中，监听到文件变更后，会用`websocket`通知浏览器，重新发起新的请求，只对该模块进行重新编译，然后进行替换。

并且基于`es module`的特性，vite利用浏览器的缓存策略，针对源码模块（我们自己写的代码）做了`协商缓存`处理，针对依赖模块（第三方库）做了`强缓存`处理，这样我们项目的访问的速度也就更快了。

## 生产环境

Rollup 是一款 `ES Module` 打包器， 从作用上来看，`Rollup` 与 `Webpack` 非常类似。不过相比于 `Webpack`，`Rollup`要小巧的多，打包生成的文件更小。 因为小巧，自然在这种特定的打包环境下，`Rollup`的打包速度也要比 `Webpack` 快很多。

vite正是基于`es module`的特性实现的，所以使用rollup要更合适一些。

**vite生产环境下，为什么不用esbuild打包呢？**

尽管esbuild的打包速度比rollup更快，但 Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容，rollup插件api与基础建设更加完善，所以在生产环境vite使用rollup打包会更稳定一些。

如果后面esbuild基础建设与生态更加完善后，esbuild还是更有优势的。

所以使用vite可能会带来开发环境与生产环境打包结果不一致的问题。


webpack很多东西要自己搭建，比如：`跨域`、`代码压缩`、`代码分割`、`css预处理器的代码转换`、`样式兼容性`、`vue/react代码解析`、`图片压缩`、`代码热更新`、`es降级`、`ts转换`等等。vite对这些常用功能都做了内置支持。




# 介绍项目+项目难点亮点+怎么解决

## 打印部分
### 在一个PDF输入太多导致报错
输入长度超过限制
解决：通过pnpm patch去改源码库
###  文字重叠
因为把节点渲染在受transform影响的节点之内导致的
解决：通过查阅资料之后，发现需要把节点挂载到transform节点之外，比如body旁边

# CMS
背景：每次运营有活动都需要开发去开发新的页面



# SEO优化

使用语义化标签
在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。
img 添加 alt 属性，用 h1 标签去写内容关键字

meta标签

**A. Keywords(关键词，很重要)**  
说明：规定一个逗号分隔的关键词列表（告诉搜索引擎页面是与什么相关的）。


`例如：<meta name="keywords" content="掘金,稀土,Vue.js,前端面试题,Kotlin,ReactNative,Python">`

**B. description(网站内容描述，很重要)**  
说明：规定页面的描述。搜索引擎会把这个描述显示在搜索结果中。

`例如：<meta name="description" content="掘金是面向全球中文开发者的技术内容分享与交流平台。我们通过技术文章、沸点、课程、直播等产品和服务，打造一个激发开发者创作灵感，激励开发者沉淀分享，陪伴开发者成长的综合类技术社区。">`

**C. author**  
说明：作者的名字


`例如：<meta name="author" content="Hege Refsnes">`

**D. generator**  
说明：代表说明网站的采用的什么软件制作。


`例如：<meta name="generator" content="Hege Refsnes">`

**E. theme-color**  
说明：代表页面显示设计的建议颜色。


`例如：<meta name="theme-color" content="#4285f4" />`

**1.2 http- equiv**

http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容。  
meta标签的http-equiv属性语法格式是： `<meta http-equiv="参数"content="参数变量值">；`  
其中http-equiv属性主要有以下几种参数：

## 确保页面性能

## sitemap站点地图
## 使用HTTPS

# es6 和后面新的api

[ES6 完全使用手册此外还要注意这里不一定就是正式进入规范的语法。 1. let 和 const 在我们开发的时候，可能 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903726201700365?searchId=2024082815002430731E303B990D645B53)