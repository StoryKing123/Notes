
# HTML
## HTML离线缓存
离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。  
  
原理：HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示
使用方法：  
1. 创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：
```html
<html lang="en" manifest="index.manifest">
```
2. 在 cache.manifest 文件中编写需要离线存储的资源：
```
CACHE MANIFEST
    #v0.11
    CACHE:
    js/app.js
    css/style.css
    NETWORK:
    resourse/logo.png
    FALLBACK:
    / /offline.html
```

CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。  
●NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。  
●FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。
3. 在离线状态时，操作 window.applicationCache 进行离线缓存的操作。

## iframe 有那些优点和缺点？
iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。

优点：  
* 用来加载速度较慢的内容（如广告）  
* 可以使脚本可以并行下载  
* 可以实现跨子域通信  
  
缺点：  
* iframe 会阻塞主页面的 onload 事件  
* 无法被一些搜索引擎索识别  
* 会产生很多页面，不容易管理
## label 的作用是什么？如何使用？
label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。  
```html
<label for="mobile">Number:</label>

<input type="text" id="mobile"/>


<label>Date:<input type="text"/></label>

```

## Canvas和SVG的区别
### SVG：
SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
其特点如下：  
* 不依赖分辨率  
* 支持事件处理器  
* 最适合带有大型渲染区域的应用程序（比如谷歌地图）  
* 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）  
* 不适合游戏应用

### Canvas:
依赖分辨率  
* 不支持事件处理器  
* 弱的文本渲染能力  
* 能够以 .png 或 .jpg 格式保存结果图像  
* 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

# 渐进增强和优雅降级之间的区别
1. 渐进增强（progressive enhancement）：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。  
2. 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。

# CSS




## 优先级
样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。

## CSS中可继承与不可继承属性有哪些
无继承性的属性  
1display：规定元素应该生成的框的类型  
2文本属性：  
●vertical-align：垂直文本对齐  
●text-decoration：规定添加到文本的装饰  
●text-shadow：文本阴影效果  
●white-space：空白符的处理  
●unicode-bidi：设置文本的方向  
3盒子模型的属性：width、height、margin、border、padding  
4背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment  
5定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index  
6生成内容属性：content、counter-reset、counter-increment  
7轮廓样式属性：outline-style、outline-width、outline-color、outline  
8页面样式属性：size、page-break-before、page-break-after  
9声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during

有继承性的属性
1字体系列属性  
●font-family：字体系列  
●font-weight：字体的粗细  
●font-size：字体的大小  
●font-style：字体的风格  
2文本系列属性  
●text-indent：文本缩进  
●text-align：文本水平对齐  
●line-height：行高  
●word-spacing：单词之间的间距  
●letter-spacing：中文或者字母之间的间距  
●text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）  
●color：文本颜色  
3元素可见性  
●visibility：控制元素显示隐藏  
4列表布局属性  
●list-style：列表风格，包括list-style-type、list-style-image等  
5光标属性  
●cursor：光标显示为何种形态

## display

| 属性值          | 作用                            |
| ------------ | ----------------------------- |
| none         | 元素不显示，并且会从文档流中移除。             |
| block        | 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。    |
| inline       | 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 |
| inline-block | 默认宽度为内容宽度，可以设置宽高，同行显示。        |
| list-item    | 像块类型元素一样显示，并添加样式列表标记。         |
| table        | 此元素会作为块级表格来显示。                |
| inherit      | 规定应该从父元素继承display属性的值。        |

## 隐藏元素的方法
### display:none
不会在DOM树上出现
### visibility:hidden
隐藏元素，但元素所占的空间仍然保留，其他元素不会受到影响。
### opacity:0
使元素透明，但元素仍然存在于页面上，并且可以与其他元素交互。
### position:absolute 
设置位置到页面之外

### z-index设为负数
使其他元素遮盖住该元素，以此来实现隐藏

###  clip/clip-path
裁剪元素实现隐藏

###  transform: scale(0,0)
将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

## link和@import的区别
  
* link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
* link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载，可能会阻塞页面的渲染。
* link支持使用Javascript控制DOM去改变样式；而@import不支持。
- 如果同时使用 `link` 和 `@import` 引入了相同的样式表，`link` 引入的样式表通常具有更高的优先级。

## display:none与visibility:hidden的区别
这两个属性都是让元素隐藏，不可见。两者区别如下：
在渲染树中  
●display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；  
●visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见
是否是继承属性  
●display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；  
●visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；
修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；


## 伪元素和伪类的区别和作用？
  
伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：
```css
p::before {content:"第一章：";}
p::after {content:"Hot!";}
p::first-line {background:red;}
p::first-letter {font-size:30px;}
```

伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：
```css
  
a:hover {color: #FF00FF}

p:first-child {color: red}
```

## CSS 优化和提高性能的方法有哪些？
css压缩：将写好的css进行打包压缩，可以减小文件体积。
减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择
尽量少的去对标签进行选择，而是用class。
尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素
了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则

## display:inline-block 什么时候会显示间隙
有空格时会有间隙，可以删除空格解决；
margin正值时，可以让margin使用负值解决；
使用font-size时，可通过设置font-size:0、letter-spacing、word-spacing解决

## 单行、多行文本溢出隐藏
单行文本溢出
```css
  
overflow: hidden; // 溢出隐藏

text-overflow: ellipsis; // 溢出用省略号显示

white-space: nowrap; // 规定段落中的文本不进行换行
```

多行文本溢出
```css
overflow: hidden;            // 溢出隐藏
text-overflow: ellipsis;     // 溢出用省略号显示
display:-webkit-box;         // 作为弹性伸缩盒子模型显示。
-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列
-webkit-line-clamp:3;        // 显示的行数
```

## 如何判断元素是否到达可视区域
### 计算距离
### 通过intersectionObserver API？？

## z-index属性在什么情况下会失效
通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。

index属性在下列情况下会失效：  
* 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；  
* 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；  
* 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；


## 浮动元素引起的问题？
  
父元素的高度无法被撑开，影响与父元素同级的元素  
●与浮动元素同级的非浮动元素会跟随其后  
●若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构
## 清除浮动的方式如下：
  
* 给父级div定义height属性  
* 最后一个浮动元素之后添加一个空的div标签，并添加clear:both样式  
* 包含浮动元素的父级标签添加overflow:hidden或者overflow:auto  
* 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**

## BFC
* Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。  
* Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。
块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。

通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。

创建BFC的条件：  
* 根元素：body；  
* 元素设置浮动：float 除 none 以外的值；  
* 元素设置绝对定位：position (absolute、fixed)；  
* display 值为：inline-block、table-cell、table-caption、flex等；  
* overflow 值为：hidden、auto、scroll；  
  
BFC的特点：  
* 垂直方向上，自上而下排列，和文档流的排列方式一致。  
* 在BFC中上下相邻的两个容器的margin会重叠  
* 计算BFC的高度时，需要计算浮动元素的高度  
* BFC区域不会与浮动的容器发生重叠  
* BFC是独立的容器，容器内部元素不会影响外部元素  
* 每个元素的左margin值和容器的左border相接触  
  
BFC的作用：  
* 解决margin的重叠问题：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。  
* 解决高度塌陷的问题：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置overflow:hidden。  
* 创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。


## 元素的层叠顺序
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240831101641.png)

对于上图，从上到下的层级分别是：

1. **背景和边框**：建立当前层叠上下文元素的背景和边框。
2. **负的 z-index**：当前层叠上下文中，z-index 属性值为负的元素。
3. **块级盒**：文档流内非行内级非定位后代元素。
4. **浮动盒**：非定位浮动元素。
5. **行内盒**：文档流内行内级非定位后代元素。
6. **z-index:0**：层叠级数为 0 的定位元素。
7. **正 z-index**：z-index 属性值为正的定位元素。

注意：当定位元素的 z-index 为 auto 时，生成的盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非它是根元素。

## position的属性有哪些，区别是什么
position有以下属性值：  


| 属性值      | 概述                                                                                                                                                                                      |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| absolute | 生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。                                                                                                                   |
| relative | 生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。                                                                                                                             |
| fixed    | 生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。                                                                                                          |
| static   | 默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。                                                                                               |
| inherit  | 规定从父元素继承position属性的值                                                                                                                                                                    |
| sticky   | 在元素到达特定位置之前，它会按照正常的文档流进行布局，表现得像相对定位。<br><br>当元素到达特定位置（通常通过设置 `top`、`bottom`、`left`、`right` 属性来定义这个特定位置）时，它就会 “粘” 在那个位置上，表现得像固定定位，不随页面滚动而移动。<br><br>如果父元素没有足够的空间让粘性元素到达其特定位置，粘性定位可能不会生效。 |

## absolute与fixed共同点与不同点
共同点：  
* 改变行内元素的呈现方式，将display置为inline-block    
* 使元素脱离普通文档流，不再占据文档物理空间  
* 覆盖非定位文档元素  
  
不同点：  
* absolute与fixed的根元素不同，absolute的根元素可以设置，fixed根元素是浏览器。  
* 在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。

## 设置小于12px的字体
在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。
  
解决办法：  
●使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。  
●使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；  
●使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。


## 如何解决 1px 问题？
1px 问题指的是：在一些 Retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：
思路一：直接写 0.5px

**使用 CSS 媒体查询和缩放**
```css
.border-1px {
  border: 1px solid #000;
}

@media screen and (-webkit-min-device-pixel-ratio: 2) {
 .border-1px {
    border-width: 0.5px;
  }
}

@media screen and (-webkit-min-device-pixel-ratio: 3) {
 .border-1px {
    border-width: 0.333333px;
  }
}
```
思路二：伪元素先放大后缩小
```css
.border-1px {
  position: relative;
}

.border-1px::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 1px solid #000;
  -webkit-transform: scaleY(0.5);
  transform: scaleY(0.5);
  -webkit-transform-origin: top left;
  transform-origin: top left;
}

@media screen and (-webkit-min-device-pixel-ratio: 2) {
 .border-1px::after {
    -webkit-transform: scaleY(0.5);
    transform: scaleY(0.5);
  }
}

@media screen and (-webkit-min-device-pixel-ratio: 3) {
 .border-1px::after {
    -webkit-transform: scaleY(0.333333);
    transform: scaleY(0.333333);
  }
}
```

使用 box-shadow
```css
.border-1px {
  box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);
}
```

## 响应式布局 
原理：一套代码，
去适应多端的页面布局，而不是单独的两套
实现：
* 媒体查询
给不同屏幕的大小编写不同的样式来实现响应式的布局
缺点：
对于复杂的响应式设计，可能需要编写大量的媒体查询代码，增加了代码的复杂性和维护难度。
只能基于一些预定义的条件进行判断，对于一些特殊的需求可能无法满足
```css
@media screen and (max-device-width:960px){     body{background:red;} }
```
* rem
1rem=html根元素标签的fontsize
* vw、vh
因为 100vw = 100视图窗宽度 ，100vh = 100 视图窗高度，那么按照750的设计稿100vw就是750.那么1vw就是7.5px
* flex 弹性布局
* 容器查询 
更有灵活性，但是兼容性差




## 居中
1. **使用 Flex 布局**：
    
    - 将父元素设置为 Flex 容器，并使用`justify-content: center;`和`align-items: center;`来使子元素在水平和垂直方向上居中。
2. **使用 Grid 布局**：
    
    - 将父元素设置为 Grid 容器，并使用`place-items: center;`来使子元素在网格中居中。
3. **使用绝对定位和负边距**：
    
    - 将子元素设置为绝对定位，并使用`top: 50%; left: 50%; transform: translate(-50%, -50%);`来使其在父元素中居中。
4. **使用文本居中**：
    
    - 对于文本元素，可以使用`text-align: center;`来使其在父元素中水平居中。
5. **使用 margin 自动**：
    
    - 如果子元素的宽度已知，可以将其左右 margin 设置为`auto`，以使其在父元素中水平居中。



# JS
JavaScript有哪些数据类型，它们的区别？
JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。  
  
其中 Symbol 和 BigInt 是ES6 中新增的数据类型：  
●Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。  
●BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。  
  
这些数据可以分为原始数据类型和引用数据类型：  
●栈：原始数据类型（Undefined、Null、Boolean、Number、String）  
●堆：引用数据类型（对象、数组和函数）  
  
两种类型的区别在于存储位置的不同：  
●原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；  
●引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。  
  
堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：  
●在数据结构中，栈中数据的存取方式为先进后出。  
●堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。  
  
在操作系统中，内存被分为栈区和堆区：  
●栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  
●堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。

## 判断数组的方式有哪些

```js
//通过Object.prototype.toString.call()做判断
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';


//通过原型链做判断
obj.__proto__ === Array.prototype;

//通过ES6的Array.isArray()做判断
Array.isArrray(obj);

//通过instanceof做判断
obj instanceof Array

//通过Array.prototype.isPrototypeOf
Array.prototype.isPrototypeOf(obj)

```

## null和undefined区别
首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。  
  
undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。  
  
undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。  
  
当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。

## typeof null 的结果是什么，为什么？
typeof null 的结果是Object。  
  
在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：

```js
000: object - 当前存储的数据指向一个对象。 
  1: int - 当前存储的数据是一个 31 位的有符号整数。 
010: double - 当前存储的数据指向一个双精度的浮点数。 
100: string - 当前存储的数据指向一个字符串。 
110: boolean - 当前存储的数据是布尔值。
```

如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。  
  
有两种特殊数据类型：  
* undefined的值是 (-2)30(一个超出整数范围的数字)；  
* null 的值是机器码 NULL 指针(null 指针的值全是 0)  
  
那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。

## intanceof 操作符的实现原理及实现
instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
```js
function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left)
  // 获取构造函数的 prototype 对象
  let prototype = right.prototype; 
 
  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;
    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型
    proto = Object.getPrototypeOf(proto);
  }
}
```

## 为什么0.1+0.2 ! == 0.3，如何让其相等

https://www.yuque.com/cuggz/interview/vgbphi#07bd225009b56575a79bacf9c659d4e7
计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？  
  
一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。  
  
根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。

对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 ===0.3
```js
function numberepsilon(arg1,arg2){

return Math.abs(arg1 - arg2) < Number.EPSILON;

}

  

console.log(numberepsilon(0.1 + 0.2, 0.3)); // true
```

## typeof NaN 的结果是什么？
NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。
```js
typeof NaN; // "number"
```
NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。


## isNaN 和 Number.isNaN 函数的区别？

isNaN会有类型转换
* 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。  
* 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。

## 其他值到字符串的转换规则？
* Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"，  
* Boolean 类型，true 转换为 "true"，false 转换为 "false"。  
* Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。  
* Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。  
* 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。

## 其他值到数字值的转换规则？
* Undefined 类型的值转换为 NaN。  
* Null 类型的值转换为 0。  
* Boolean 类型的值，true 转换为 1，false 转换为 0。  
* String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。  
* Symbol 类型的值不能转换为数字，会报错。  
* 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

## 其他值到布尔类型的值的转换规则？
以下这些是假值：  
* undefined  
* null  
* false  
* +0、-0 和 NaN  
* ""

## Object.is() 与比较操作符`===`与 `==`的区别？
* 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。  
* 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。  
* 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。

## 什么是 JavaScript 中的包装类型？
在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：
```js
const a = "abc"; 
a.length; // 3 
a.toUpperCase(); // "ABC"
```

## object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别
### 扩展运算符：
```js
let outObj = {
  inObj: {a: 1, b: 2}
}
let newObj = {...outObj}
newObj.inObj.a = 2
console.log(outObj) // {inObj: {a: 2, b: 2}}
```

### Object.assign():
```js
let outObj = {
  inObj: {a: 1, b: 2}
}
let newObj = Object.assign({}, outObj)
newObj.inObj.a = 2
console.log(outObj) // {inObj: {a: 2, b: 2}}
```
可以看到，两者都是浅拷贝。  
* Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。  
* 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。


## 如何判断一个对象是空对象
```js
//使用JSON自带的.stringify方法来判断
if(Json.stringify(Obj) == '{}' ){
    console.log('空对象');
}

//使用ES6新增的方法Object.keys()来判断：
if(Object.keys(Obj).length < 0){
    console.log('空对象');
}
```

## ES6
### let、const、var的区别
（1）块级作用域：块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：  
●内层变量可能覆盖外层变量  
●用来计数的循环变量泄露为全局变量  
（2）变量提升：var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。  
（3）给全局添加属性：浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。  
（4）重复声明：var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。  
（5）暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。  
（6）初始值设置：在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。  
（7）指针指向：let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。


| 区别        | var | let | const |
| --------- | --- | --- | ----- |
| 是否有块级作用域  | ✗   | ✓   | ✓     |
| 是否存在变量提升  | ✓   | ✗   | ✗     |
| 是否添加全局属性  | ✓   | ✗   | ✗     |
| 能否重复声明变量  | ✓   | ✗   | ✗     |
| 是否存在暂时性死区 | ✗   | ✓   | ✓     |
| 是否必须设置初始值 | ✗   | ✗   | ✓     |
| 能否改变指针指向  | ✓   | ✓   | ✗     |

### const对象的属性可以修改吗
const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。  
  
但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。


### 剪头函数
箭头函数是 JavaScript 中一种简洁的函数声明方式，它有以下几个主要特点：

1. 简洁的语法：
    - 对于单个参数，可以省略括号
    - 如果函数体只有一个表达式，可以省略大括号和 return 关键字
2. 词法 this 绑定：
    - 箭头函数不会创建自己的 this 上下文，而是继承外围作用域的 this 值
    - 这解决了传统函数中 this 指向不确定的问题
    - 箭头函数继承来的this指向永远不会改变
    - call()、apply()、bind()等方法不能改变箭头函数中this的指向
3. 不能用作构造函数：
    - 箭头函数不能使用 new 关键字调用，因为它没有自己的 this
4. 没有 arguments 对象：
    - 箭头函数没有自己的 arguments 对象，但可以访问外围函数的 arguments 对象
5. 没有 prototype 属性
6. 不能用作生成器函数：
    - 箭头函数不能使用 yield 关键字

### new操作符的实现原理
new操作符的执行过程：  
（1）首先创建了一个新的空对象  
（2）设置原型，将对象的原型设置为函数的 prototype 对象。  
（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）  
（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

```js
function objectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}
// 使用方法
objectFactory(构造函数, 初始化参数);
```

```mermaid
graph TD
    A[开始] --> B[创建新的空对象]
    B --> C[设置对象的原型为构造函数的prototype]
    C --> D[将构造函数的this指向新对象]
    D --> E[执行构造函数代码]
    E --> F{构造函数是否有返回值?}
    F -->|无返回值| G[返回新创建的对象]
    F -->|有返回值| H{返回值是否为对象?}
    H -->|是| I[返回该对象]
    H -->|否| G
    G --> J[结束]
    I --> J
```


### map和weakMap的区别
（1）Map  
map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。
Map数据结构有以下操作方法：  
* size： map.size 返回Map结构的成员总数。  
* set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）  
* get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。  
* has(key)：该方法返回一个布尔值，表示某个键是否在当前Map对象中。  
* delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。  
* clear()：map.clear()清除所有成员，没有返回值。  
  
Map结构原生提供是三个遍历器生成函数和一个遍历方法  
* keys()：返回键名的遍历器。  
* values()：返回键值的遍历器。  
* entries()：返回所有成员的遍历器。  
* forEach()：遍历Map的所有成员。


WeakMap  
WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的。该对象也有以下几种方法：  
* set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）  
* get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。  
* has(key)：该方法返回一个布尔值，表示某个键是否在当前Map对象中。  
* delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。  
其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。  
  
WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。  
  
而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。


总结：  
* Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。  
* WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制

### JavaScript脚本延迟加载的方式有哪些
延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。
一般有以下几种方式：  
* defer 属性：给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。  
* async 属性：给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。  
* 动态创建 DOM 方式：动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。  
* 使用 setTimeout 延迟方法：设置一个定时器来延迟加载js脚本文件  
* 让 JS 最后加载：将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。

### JavaScript 类数组对象的定义？
将类数组转换成真正的数组
```js
Array.prototype.slice.call(arrayLike);
Array.prototype.splice.call(arrayLike, 0);
Array.prototype.concat.apply([], arrayLike);
Array.from(arrayLike);
```

### Slice和Splice的区别

1. slice 方法：

- 用途：从数组中提取一部分元素，返回一个新数组
- 语法：array.slice(start, end)
- 特点：
    - 不修改原数组
    - start 和 end 参数可选
    - 返回一个新数组，包含从 start 到 end（不包括 end）的元素
2. splice 方法：

- 用途：在数组中添加或删除元素
- 语法：array.splice(start, deleteCount, item1, item2, ...)
- 特点：
    - 修改原数组
    - start 参数必需，其他可选
    - 可以删除元素、添加元素，或同时进行这两种操作
    - 返回被删除的元素组成的数组

总结：
1. 功能不同：
    - slice 是用来"切片"，只是复制数组的一部分
    - splice 功能更强大，可以删除、插入、替换数组元素
2. 对原数组的影响：
    - slice 不修改原数组
    - splice 会修改原数组
3. 返回值：
    - slice 返回提取的元素组成的新数组
    - splice 返回被删除的元素组成的数组
4. 参数：
    - slice 接受开始和结束索引
    - splice 接受开始索引、删除数量，以及要插入的新元素
5. 使用场景：
    - 当你只想复制数组的一部分而不修改原数组时，使用 slice
    - 当你需要在数组中间插入或删除元素时，使用 splice

记忆技巧：可以将 "splice" 理解为 "surgery"（外科手术），因为它会直接修改原数组。而 "slice" 就像切蛋糕一样，只是取走一部分，不影响原来的蛋糕。


### Unicode、UTF-8、UTF-16、UTF-32的区别？
ASCII码可以表示的编码有限，要想表示其他语言的编码，还是要使用Unicode来表示，可以说Unicode是ASCII 的超集。
Unicode全称 Unicode Translation Format，又叫做统一码、万国码、单一码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。  
  
Unicode的实现方式（也就是编码方式）有很多种，常见的是UTF-8、UTF-16、UTF-32和USC-2。

可以说Unicode是一个标准，UTF-8是一个实现。

（2）UTF-8  
UTF-8是使用最广泛的Unicode编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容ASCII码的128个字符。  
  
注意： UTF-8 是一种编码方式，Unicode是一个字符集合。
总结
Unicode 是编码字符集（字符集），而UTF-8、UTF-16、UTF-32是字符集编码（编码规则）；  
* UTF-16 使用变长码元序列的编码方式，相较于定长码元序列的UTF-32算法更复杂，甚至比同样是变长码元序列的UTF-8也更为复杂，因为其引入了独特的代理对这样的代理机制；  
* UTF-8需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而UTF-16不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；  
* 如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用UTF-8就比UTF-16节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么UTF-16就占优势了，可以节省很多空间；

### 原码、补码、反码
上面提到了补码、反码等知识，这里就补充一下。  
计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。  
（1）原码  
原码就是一个数的二进制数。  
例如：10的原码为0000 1010  
（2）反码  
* 正数的反码与原码相同，如：10 反码为 0000 1010  
* 负数的反码为除符号位，按位取反，即0变1，1变0。  
例如：-10
```js
原码：1000 1010 
反码：1111 0101
```
（3）补码  
* 正数的补码与原码相同，如：10 补码为 0000 1010  
* 负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。  
例如：-10
```js
原码：1000 1010 
反码：1111 0101 
补码：1111 0110
```


## 什么是 DOM 和 BOM
* DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。  
* BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。

## escape、encodeURI、encodeURIComponent 的区别
* encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。  
* encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。  
* escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。

## ES6模块与CommonJS模块有什么异同？
ES6 Module和CommonJS模块的区别：  
* CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；  
* import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。  
  
ES6 Module和CommonJS模块的共同点：  
* CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。


## 原型链
[Blog/articles/深入系列文章/JavaScript深入之从原型到原型链.md at master · mqyqingfeng/Blog (github.com)](https://github.com/mqyqingfeng/Blog/blob/master/articles/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE.md)
在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。  
  
当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。  
  
特点：JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。


## for...in和for...of的区别
for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下  
* for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；  
* for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；  
* 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；  
  
总结：for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。

## 如何获得对象非原型链上的属性
```js
function iterate(obj){
   var res=[];
   for(var key in obj){
        if(obj.hasOwnProperty(key))
           res.push(key+': '+obj[key]);
   }
   return res;
} 
```


## this
对this对象的理解
this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。  
* 第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。  
* 第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。  
* 第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。  
* 第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。  
  
这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。


## call() 和 apply() 的区别
它们的作用一模一样，区别仅在于传入参数的形式的不同。  
* apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。  
* call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。


## 继承
### JavaScript对象继承方法概览

JavaScript中有多种实现对象继承的方法,每种方法都有其优缺点。本文将概述主要的继承方式及其特点。

### 1. 原型链继承

#### 实现方式

```javascript
function Parent() {
  this.name = 'parent';
}

function Child() {}

Child.prototype = new Parent();
```

#### 优点
- 实现简单
- 可以继承父类的属性和方法

#### 缺点
- 所有实例共享父类实例的属性,可能会互相影响
- 无法向父类构造函数传参

### 2. 构造函数继承

#### 实现方式

```javascript
function Parent(name) {
  this.name = name;
}

function Child(name) {
  Parent.call(this, name);
}
```

#### 优点
- 可以向父类构造函数传参
- 不会共享父类的引用属性

#### 缺点
- 无法继承父类原型上的方法
- 每次创建实例都会创建一遍方法

### 3. 组合继承

#### 实现方式

```javascript
function Parent(name) {
  this.name = name;
}

Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;
```

#### 优点
- 结合了原型链和构造函数的优点
- 是最常用的继承方式

#### 缺点
- 调用了两次父类构造函数,性能略有影响

### 4. 原型式继承

#### 实现方式

```javascript
function createObj(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
```

#### 优点
- 不需要定义构造函数就可以实现继承

#### 缺点
- 所有实例会共享原型对象的属性
- 无法传参

### 5. 寄生式继承

#### 实现方式

```javascript
function createObj(o) {
  var clone = Object.create(o);
  clone.sayName = function() {
    console.log('hi');
  };
  return clone;
}
```

#### 优点
- 可以在原型式继承的基础上添加新属性和方法

#### 缺点
- 同原型式继承

### 6. ES6 class继承

#### 实现方式

```javascript
class Parent {
  constructor(name) {
    this.name = name;
  }
  
  sayName() {
    console.log(this.name);
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name);
    this.age = age;
  }
}
```

#### 优点
- 语法简洁,更接近传统的面向对象编程
- 实现了构造函数和原型的继承

#### 缺点
- 仅语法糖,本质上还是基于原型的继承

### 总结

每种继承方式都有其适用场景,选择时需要根据具体需求权衡利弊。在实际开发中,组合继承和ES6的class继承是较为常用的方式。

## 垃圾回收与内存泄漏

### 浏览器的垃圾回收机制
垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。
回收机制：  
* Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。  
* JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。  
* 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。
1. 标记清除  
* 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。  
* 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。  
2. 引用计数  
* 另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。  
* 这种方法会引起循环引用的问题：例如： obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。

减少垃圾回收
虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。  
* 对数组进行优化：在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。  
* 对object进行优化：对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。  
* 对函数进行优化：在循环中的函数表达式，如果可以复用，尽量放在函数的外面。

## 哪些情况会导致内存泄漏
* 意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。  
* 被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。  
* 脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。  
* 闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。

## 
## js判断数据类型
### typeof
只能判断基础类型和引用类型
判断 null结果是object
```js
console.log(typeof 123); // "number"
console.log(typeof "hello"); // "string"
console.log(typeof true); // "boolean"
console.log(typeof undefined); // "undefined"
console.log(typeof null); // "object"
console.log(typeof {}); // "object"
console.log(typeof []); // "object"
console.log(typeof function(){}); // "function"
console.log(typeof null); // "object"
console.log(typeof NaN); // "number"
console.log(typeof document.all); // "undefined"

```
### construct
- `constructor` 指向创建该实例对象的构造函数
```js
const arr = [1, 2, 3];
console.log(arr.constructor === Array) // true

const obj = {name: "云牧", age: 18};
console.log(obj.constructor === Object) // true


String.prototype.constructor = function fn() {
  return {};
}

// constructor 可以被改写
console.log("云牧".constructor) // [Function: fn]

```
### instanceof

- 语法：`obj instanceof Type`
- 功能：判断 `obj` 是不是 `Type` 类的实例，只可用来判断引用数据
- 实现思路： `Type` 的原型对象是否是 `obj` 的原型链上的某个对象
- 注意：右操作数必须是函数或者 class
```js
const arr = [1, 2, 3]
console.log(arr instanceof Array) // true
console.log(arr instanceof Object) // true

const obj = { name: "云牧", age: 18 }
console.log(obj instanceof Object) // true
console.log(obj instanceof Array) // false

```


### Object.prototype.toString
- 利用函数动态 this 的特性
```js
Object.prototype.toString.call(123); // "[object Number]"
Object.prototype.toString.call("hello"); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function(){}); // "[object Function]"
// 注意的是，Object.prototype.toString.call 方法返回的字符串格式为 "[object 类型]"

// 封装
function typeOf(data) {
  return Object.prototype.toString.call(data).slice(8, -1);
}

// 测试
console.log(typeOf(1)); // Number
console.log(typeOf("1")); // String
console.log(typeOf(true)); // Boolean
console.log(typeOf(null)); // Null
console.log(typeOf(undefined)); // Undefined
console.log(typeOf(Symbol(1))); // Symbol
console.log(typeOf({})); // Object
console.log(typeOf([])); // Array
console.log(typeOf(function () {})); // Function
console.log(typeOf(new Date())); // Date
console.log(typeOf(new RegExp())); // RegExp

```


# Vue
## 原理


当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。

![](https://raw.githubusercontent.com/StoryKing123/pics/main/20240831190032.png)

Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：  
1需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化  
2compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图  
3Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。  
4MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。





![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240831185958.png)

## Computed 和 Watch 的区别



- computed (计算属性):
    - 用于派生状态,基于现有数据计算新值
    - 有缓存机制,只在依赖项变化时重新计算
    - 返回一个不可变的响应式引用
    - 适用于需要缓存的复杂计算
- watch (侦听器):
    - 用于观察数据变化并执行副作用
    - 可以访问新值和旧值
    - 可以观察特定的数据源
    - 适用于需要在数据变化时执行异步或开销较大的操作
- watchEffect:
    - 立即运行一个函数,同时响应式地追踪其依赖
    - 自动追踪所有响应式依赖
    - 不需要指定要观察的数据源
    - 适用于执行一些副作用,但不需要分离依赖源的情况
    - 无法直接获取被监听数据的新旧值
`watch` 提供了更细粒度的控制，而 `watchEffect` 则更加简洁和自动化。选择使用哪一个主要取决于具体需求和代码复杂度。

  
* 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。  
* 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。
* watchEffect会自动收集依赖，所以不好控制收集项，适用于简单需求
## 常见的事件修饰符及其作用

* .stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；  
* .prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；  
* .capture ：与事件冒泡的方向相反，事件捕获由外到内；  
* .self ：只会触发自己范围内的事件，不包含子元素；  
* .once ：只会触发一次。

## v-if和v-show的区别
* 手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；  
* 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；  
* 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；  
* 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；  
* 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。


## 模板HTML和JSX

对于 runtime 来说，只需要保证组件存在 render 函数即可，所有template和jsx最后都会生成render函数，只不过中间过程不一样
如果使用Template编写的话，下面是步骤
- **Template（模板）**： 这是开始的地方，就是您在Vue组件中编写的HTML模板。
- **Parse（解析）**： 模板被解析成抽象语法树（AST）。AST是一个嵌套的对象，代表了模板的结构。
- **AST（抽象语法树）**： 这是模板的中间表示，包含了模板的结构和各个元素的信息。
- **Transform（转换）**： 这一步对AST进行一系列的转换和优化。例如，它可能会进行静态树提升（hoisting）、预编译等优化操作。
- **Generate（生成）**： 最后，优化后的AST被用来生成实际的渲染函数。
- **Render函数**： 这是最终的输出，一个JavaScript函数，当被调用时会创建虚拟DOM节点树。
会做一些优化，如静态节点优化之类的

如果使用JSX，下面是步骤
- **JSX**： 这是起点。你直接在JavaScript/TypeScript文件中编写JSX代码。
- **Transform（转换）**： JSX代码会被转换成标准的JavaScript函数调用。这个过程通常由Babel或TypeScript编译器完成。在Vue的上下文中，JSX通常被转换成`h`函数（createElement）的调用。
- **Render函数**： 转换后的代码本质上就是一个render函数，它会在运行时创建虚拟DOM节点树。
所以使用JSX会失去Vue模板编译器提供的一些特定优化，但是会带来灵活性


## Vue自定义指令
用于对dom的操作或者样式的修改。比方说按钮权限显隐、防抖节流、点击放大缩小这种操作，可以使用Vue的自定义指令
一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;

例如  鼠标聚焦，自定义指令实现图片懒加载



## nextTick
[全局 API：常规 | Vue.js (vuejs.org)](https://cn.vuejs.org/api/general.html#nexttick)
当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。
`nextTick()` 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise。

```vue
<script setup>
import { ref, nextTick } from 'vue'

const count = ref(0)

async function increment() {
  count.value++

  // DOM 还未更新
  console.log(document.getElementById('counter').textContent) // 0

  await nextTick()
  // DOM 此时已经更新
  console.log(document.getElementById('counter').textContent) // 1
}
</script>

<template>
  <button id="counter" @click="increment">{{ count }}</button>
</template>
```



## vue性能优化
（1）编码阶段  
* 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher  
* v-if和v-for不能连用  
>  因为在Vue2中for的优先级会比if更高（Vue3中两者优先级相反），所以如果将for和if放在同一个节点下面的时候，会将所有节点都渲染一遍，然后再通过if干掉。  
最优的方式是：  
使用computed计算出满足if条件的数据，然后再使用v-for做渲染。
* 如果需要使用v-for给每项元素绑定事件时使用事件代理  
* SPA 页面采用keep-alive缓存组件  
* 按需使用v-if和v-show
* key保证唯一  
* 使用路由懒加载、异步组件  
* 防抖、节流  
* 第三方模块按需导入  
* 长列表滚动到可视区域动态加载  
* 图片懒加载  
  
（2）SEO优化  
* 预渲染  
* 服务端渲染SSR  
  
（3）打包优化  
* 压缩代码  
* Tree Shaking/Scope Hoisting  
* 使用cdn加载第三方模块  
* 多线程打包happypack  
* splitChunks抽离公共文件  
* sourceMap优化  
  
（4）用户体验  
* 骨架屏  
* PWA  
* 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。



### 组件懒加载
### 使用computed缓存结果

### 按需使用v-if和v-show


## 对 SPA 单页面的理解，它的优缺点分别是什么？
* 页面跳转不用重新加载页面
* 资源只需要加载一次
* 服务器压力小
* 前后端解耦
缺点：
* 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
* 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；  
* SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

## Vue和React区别
### 相同点

1. **虚拟DOM**：
    
    - Vue和React都采用了虚拟DOM技术。它们都会创建一个虚拟的DOM树，并与真实DOM树进行对比，只更新有变化的部分，从而大大提高了页面的渲染性能。
2. **组件化**：
    
    - 两者都支持组件化开发，将UI拆分为可复用的组件，有助于构建大型和可维护的应用程序。
    - 两者都支持父子组件之间的数据传递（props），并且都强调单向数据流（尽管Vue通过v-model等机制实现了双向数据绑定，但本质上也是单向数据流的一种实现）。
3. **数据驱动视图**：
    
    - Vue和React都是数据驱动视图的框架，当数据发生变化时，视图会自动更新。
4. **服务端渲染**：
    
    - 两者都支持服务端渲染（SSR），有助于改善SEO和首屏加载速度。
5. **构建工具**：
    
    - Vue和React都有自己的构建工具，可以快速搭建开发环境。Vue对应的是vue-cli，而React则可以使用Create React App (CRA)。
### 区别

1. **实现原理**：
    
    - Vue采用组件响应式思想，通过getter/setter以及一些函数的劫持，能精确知道数据的变化，并触发相应的视图更新。
    - React则采用函数式组件思想，通过diff算法比较新旧虚拟DOM的差异，然后更新真实DOM。React 16还引入了Fiber架构，将DOM树微观化为链表，提高了diff算法的效率。
2. **设计结构**：
    
    - Vue使用的是可变数据，数据由data属性在Vue对象中进行管理。
    - React更强调数据的不可变性，通过setState()方法更新状态。
3. **数据流**：
    
    - Vue通过v-model等机制实现了双向数据绑定，使得数据模型和视图之间的同步更加直接。
    - React则采用单向数据流，通过props将数据从父组件传递到子组件，并通过回调函数或Context等方式实现子组件到父组件的数据传递。
4. **模板语法**：
    
    - Vue鼓励使用HTML模板语法，写起来更接近于常规的HTML结构，同时支持在模板中直接编写CSS和JavaScript。
    - React则推荐使用JSX语法，将HTML和CSS都写进JavaScript中，实现了“all in js”的理念。
5. **状态管理**：
    
    - Vue的状态管理可以通过Vuex等库实现，但Vue的核心也提供了一定程度的状态管理能力。
    - React的状态管理则更多依赖于Redux等第三方库。
6. **框架本质**：
    
    - Vue是一个渐进式框架，旨在降低前端开发的门槛，让更多的人能够更快地上手开发。它使用了MVVM框架，由MVC框架发展而来。
    - React则是一个前端组件化框架，由后端组件化发展而来。它更关注于UI的开发，提供了丰富的UI组件和API。
7. **学习曲线**：
    
    - Vue被认为对新手友好，其文档清晰且框架设计较为直观。
    - React由于其更“裸露”的性质和丰富的生态系统，可能需要更多的学习时间。
Vue默认支持数据双向绑定，而React一直提倡单向数据流
React与Vue最大的不同是模板的编写。  
* Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。  
* React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。

## assets和static的区别
相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点  
  
不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。

assets会中会对资源进行压缩优化


## SSR
SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端  
  
SSR的优势：  
* 更好的SEO  
* 首屏加载速度更快  
  
SSR的缺点：  
* 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；  
* 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；  
* 更多的服务端负载。


## MVVM的优缺点
优点:  
* 分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的"View"上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑  
* 提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码  
* ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放  
  
缺点:  
* Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的  
* ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存  
* 对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。
## Hooks
Vue中的hooks是通过响应式实现的，所以在任何地方都能使用

React中hooks是通过单链表实现的，挂载在Fiber书。根据声明hooks顺序去构建单链表。如果在条件语句中声明，会破坏hooks链表顺序
* useState
* useReducer
* useContext
* useRef
* useEffect
* useLayoutEffect
* useMemo
* useTransition
* useDeferredValue


## 常见的Vue性能优化方法
  
路由懒加载
```js
const router = new VueRouter({ routes: [
  	{ path: '/foo', component: () => import('./Foo.vue') }
  ]
})
```

  
keep-alive缓存页面
```vue
<template>
  <div id="app">
    <keep-alive>
      <router-view/>
    </keep-alive>
  </div>
</template>
```

使用v-show复用DOM
```vue
<template>
  <div class="cell">
     <!--这种情况用v-show复用DOM，比v-if效果好-->
     <div v-show="value" class="on">
        <Heavy :n="10000"/>
     </div>
     <section v-show="!value" class="off">
        <Heavy :n="10000"/>
     </section>
  </div>
</template>
```

  
v-for 遍历避免同时使用 v-if
```vue

//或者在外层使用v-if
<template>
  <ul>
		<li v-for="user in activeUsers" :key="user.id">
			{{ user.name }}
		</li>
	</ul>
</template>

<script>
export default { 
  computed: {
		activeUsers: function () {
			return this.users.filter(function (user) { 
        return user.isActive
      })
		}
	}
}
</script>
```


  
长列表性能优化
```vue
// 如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化
export default { 
	data: () => ({
		users: []
	}),
	async created() {
		const users = await axios.get("/api/users"); 
		this.users = Object.freeze(users);
	}	
};

// 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容
<recycle-scroller class="items" :items="items" :item-size="24">
	<template v-slot="{ item }">
 		<FetchItemView :item="item" @vote="voteItem(item)"/>
  </template>
</recycle-scroller>
```


事件的销毁
```vue
created() {
	this.timer = setInterval(this.refresh, 2000)
},
beforeDestroy() { 
	clearInterval(this.timer)
}
```
图片懒加载  
对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。
```vue
<img v-lazy="/static/img/1.png">
```

第三方模块按需引入

## created和mounted的区别
* created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。  
* mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

## 一般在哪个生命周期请求异步数据
我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。  
  
推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：  
* 能更快获取到服务端数据，减少页面加载时间，用户体验更好；  
* SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。

## keep-alive 中的生命周期哪些
keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。  
  
如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。  
  
当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。


## 组件通信
### props
### emits
### expose/ref

### attrs

### provide/inject

### 状态管理



## 生命周期
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829210941.png)


![[Vue3生命周期.excalidraw|675]]


## vue-router

SPA中的路由一般有两种方式去实现hash模式和hisotry模式，反正两种模式的特点都是url变化但是不会去刷新页面。
### hash router

`hash` 模式是一种把前端路由的路径用井号 `#` 拼接在真实 `url` 后面的模式。当井号 `#` 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 `onhashchange` 事件。
#### 特点
- `hash` 可以改变 `url` ，但是不会触发页面重新加载（hash的改变是记录在 `window.history` 中），即不会刷新页面。也就是说，所有页面的跳转都是在客户端进行操作。因此，这并不算是一次 `http` 请求，所以这种模式不利于 `SEO` 优化。`hash` 只能修改 `#` 后面的部分，所以只能跳转到与当前 `url` 同文档的 `url` 。
- `hash` 通过 `window.onhashchange` 的方式，来监听 `hash` 的改变，借此实现无刷新跳转的功能。
- - `hash` 永远不会提交到 `server` 端（可以理解为只在前端自生自灭）。
#### 缺点
1. 地址栏中携带#，不美观
2. 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL
3. 设置的新值必须与原来不一样才会触发hashchange事件，并将记录添加到栈中
```js
window.addEventListener("load", this.updateView.bind(this)); // hash模式 路由修改时 浏览器会触发hashchange事件 调用更新视图函数 
window.addEventListener("hashchange", this.updateView.bind(this));
```


### history router
`history API` 是 `H5` 提供的新特性，允许开发者**直接更改前端路由**，即更新浏览器 `URL` 地址而**不重新发起请求**基于HTML5新增的pushState()和replaceState()两个api，以及浏览器的popstate事件，地址变化时，浏览器不会刷新页面，通过window.location.pathname找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容。

#### 特点
1. 没有#，更加美观
2. pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL
3. pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中
4. pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中
5. pushState() 可额外设置 title 属性供后续使用
6. 浏览器的进后退能触发浏览器的popstate事件，获取window.location.pathname来控制页面的变化

#### 缺点
- 使用 `history` 模式时，在对当前的页面进行刷新时，此时浏览器会重新发起请求。如果 `nginx` 没有匹配得到当前的 `url` ，就会出现 `404` 的页面。
- 而对于 `hash` 模式来说， 它虽然看着是改变了 `url` ，但不会被包括在 `http` 请求中。所以，它算是被用来指导浏览器的动作，并不影响服务器端。因此，改变 `hash` 并没有真正地改变 `url` ，所以页面路径还是之前的路径， `nginx` 也就不会拦截。
- 因此，在使用 `history` 模式时，需要**通过服务端来允许地址可访问**，如果没有设置，就很容易导致出现 `404` 的局面。



调用 history.pushState() 相比于直接修改 hash，存在以下优势:  
* pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；  
* pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；  
* pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；  
* pushState() 可额外设置 title 属性供后续使用。  
* hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。

## Vue-router 路由钩子在生命周期的体现
有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。  
为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的  
1全局路由钩子  
全局有三个路由钩子;  
* router.beforeEach 全局前置守卫 进入路由之前  
* router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用  
* router.afterEach 全局后置钩子 进入路由之后  
具体使用∶
beforeEach（判断是否登录了，没登录就跳转到登录页）
```js
router.beforeEach((to, from, next) => {  
    let ifInfo = Vue.prototype.$common.getSession('userData');  // 判断是否登录的存储信息
    if (!ifInfo) { 
        // sessionStorage里没有储存user信息    
        if (to.path == '/') { 
            //如果是登录页面路径，就直接next()      
            next();    
        } else { 
            //不然就跳转到登录      
            Message.warning("请重新登录！");     
            window.location.href = Vue.prototype.$loginUrl;    
        }  
    } else {    
        return next();  
    }
})
```

* 全局前置/钩子：beforeEach、beforeResolve、afterEach  
* 路由独享的守卫：beforeEnter  
* 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave



## 1. 完整的路由导航解析流程（不包括其他生命周期）

1. 触发进入其他路由。
2. 调用要离开路由的组件守卫 `beforeRouteLeave`
3. 调用全局前置守卫：`beforeEach`
4. 在重用的组件里调用 `beforeRouteUpdate`
5. 调用路由独享守卫 `beforeEnter`
6. 解析异步路由组件
7. 在将要进入的路由组件中调用 `beforeRouteEnter`
8. 调用全局解析守卫 `beforeResolve`
9. 导航被确认
10. 调用全局后置钩子的 `afterEach` 钩子
11. 触发DOM更新（`mounted`）
12. 执行 `beforeRouteEnter` 守卫中传给 `next` 的回调函数

## 2. 触发钩子的完整顺序

假设从 a 组件离开，第一次进入 b 组件：

1. `beforeRouteLeave`：路由组件的组件离开路由前钩子，可取消路由离开。
2. `beforeEach`：路由全局前置守卫，可用于登录验证、全局路由loading等。
3. `beforeEnter`：路由独享守卫
4. `beforeRouteEnter`：路由组件的组件进入路由前钩子。
5. `beforeResolve`：路由全局解析守卫
6. `afterEach`：路由全局后置钩子
7. `beforeCreate`：组件生命周期，不能访问 `this`。
8. `created`：组件生命周期，可以访问 `this`，不能访问dom。
9. `beforeMount`：组件生命周期
10. `deactivated`：离开缓存组件 a，或者触发 a 的 `beforeDestroy` 和 `destroyed` 组件销毁钩子。
11. `mounted`：访问/操作dom。
12. `activated`：进入缓存组件，进入 a 的嵌套子组件（如果有的话）。
13. 执行 `beforeRouteEnter` 回调函数 `next`。

## 3. 导航行为被触发到导航完成的整个过程

1. 导航行为被触发，此时导航未被确认。
2. 在失活的组件里调用离开守卫 `beforeRouteLeave`。
3. 调用全局的 `beforeEach` 守卫。
4. 在重用的组件里调用 `beforeRouteUpdate` 守卫(2.2+)。
5. 在路由配置里调用 `beforeEnter`。
6. 解析异步路由组件（如果有）。
7. 在被激活的组件里调用 `beforeRouteEnter`。
8. 调用全局的 `beforeResolve` 守卫（2.5+），标示解析阶段完成。
9. 导航被确认。
10. 调用全局的 `afterEach` 钩子。
11. 非重用组件，开始组件实例的生命周期：`beforeCreate` & `created`、`beforeMount` & `mounted`
12. 触发 DOM 更新。
13. 用创建好的实例调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数。
14. 导航完成

## Vue-router跳转和location.href有什么区别
  
使用 location.href= /url 来跳转，简单方便，但是刷新了页面；  
* 使用 history.pushState( /url ) ，无刷新页面，静态跳转；  
* 引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为vue-router就是用了 history.pushState() ，尤其是在history模式下。

## params和query的区别
用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和 this.$route.params.name 。  
  
url地址显示：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示  
  
注意：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。




## Vuex
Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。

![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240901010628.png)

## Vuex中action和mutation的区别
mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：

Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。  
所以，两者的不同点如下：  
* Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。  
* Mutation：必须同步执行；Action：可以异步，但不能直接操作State。  
* 在视图更新时，先触发actions，actions再触发mutation  
* mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters

## Vuex 和 localStorage 的区别
1. 最重要的区别  
●vuex存储在内存中  
●localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快  
2. 应用场景  
●Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。  
●localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。  
●Vuex能做到数据的响应式，localstorage不能  
3. 永久性  
刷新页面时vuex存储的值会丢失，localstorage不会。  
注意：对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。

## Redux 和 Vuex 有什么区别，它们的共同思想
（1）Redux 和 Vuex区别  
* Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可  
* Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可  
* Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）  
  
通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;  
  
（2）共同思想  
* 单—的数据源  
* 变化可以预测  
  
本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;  
形式上：vuex借鉴了redux，将store作为全局的数据中心，进行model管理;


# 路由
[阿里P7：你了解路由吗？年后被迫跳槽，其中种种一言难尽，于是投递简历，虽然有了年前尝试积累，但年前毕竟不是真正的跳槽。由 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904113990270989?searchId=20230719194727C905D849125CD77F0962#heading-0)


# 性能优化
## CDN
CDN（Content Delivery Network，内容分发网络）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。

## 图片懒加载

# 项目性能优化
## 启动缓存
所谓的前端缓存，其实就是http缓存，通过（强缓存/协商缓存）等方式让计算机直接从缓存中读取静态资源，从而实现_节约宽带_，_提高响应速度_，_减少服务器压力_等优化。

## 开启gzip压缩
常规情况下前端部署所需要的dist包中会有一些静态文件（如js，css，图片文件）。这些静态文件会在项目初始化后续某个动作下被加载。出于体积大小的不同，加载速度也不一样。有些文件比较大，加载所需时间相对较长，针对文件加载慢的情况。

我们可以采用一些压缩方案，让这些静态文件的体积尽量变小。这样，就可以相对的_节约宽带_，而因为这些文件的变小，对这些的静态文件的_加载的速度也会得到提升_，客户端也可以尽快响应给用户一个良好的体验。

gzip有着比zip更优秀的压缩算法，可以有效的减少文件的大小。

## 使用函数节流和防抖

节流和防抖都是将我们大量重复多余的操作进行合并，以达到_减少客户端或服务端压力_，_提高运算速度_，_减少http请求_等效果。
### 节流
频繁触发一个事件时候，每隔一段时间，函数只会执行一次。
场景：
滚动条滚动事件，dom的拖拽事件等
### 防抖
当触发一个时间后的n秒内，如果该事件没有被第二次触发，则执行。否，则重新开始计时。
场景：
搜索框的搜索事件，按钮提交

## 异步加载文件

浏览器在下载和解析script文件的时候会停止html的解析和 CSSOM 的构建。

所以，在以前我们通常喜欢把< script >标签放在html的最后面。

当然，不想将< script >标签放在后面又不想让script的下载和解析影响html的渲染，也有方案。在script标签中加上_defer_属性即可。

script标签的defer属性可以让script异步加载并在DOM构建完成和CSS渲染完毕之后再执行
注意：有多种执行外部脚本的方法：
如果async="async'":脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）
如果不使用async且defe="defer”:脚本将在页面完成解析时执行
如果既不使用async也不使用defer::在浏览器继续解析页面之前，立即读取并执行脚本
  
## 减少重排和重绘
重排和重绘是浏览器中相对比较耗时的动作。尤其是重排。

_重绘不一定会引起重排。重排一定会导致重绘。_

浏览器上我们所能看见的元素。当它们的位置发生改变的时候，并不是流动的。而是先被擦除，再重新生成。这就像画画，当画上的某一个单位需要改变位置，我们无法直接把这个单位直接进行移动，只能先将其擦除，然后在指定的位置重新画一个。

元素改变位置，浏览器会先在指定位置上构建该元素的dom（重排）(注意这里没有渲染)，然后在对该元素进行渲染（比如background,color）（重绘）。

元素在位置上的改变属于重排，非位置上的改变基本属于重绘（不绝对）。

比如一个原本红色背景的div，如果仅仅改变背景为蓝色的话，那么只会触发重绘，并不会触发重排。（因为位置没有变，只有CSS改变）

  **重绘触发场景**

- background的改变
- color的改变
- visibility:hidden
- css3的translate
- color, border-style, border-radius, visibility, text-decoration, background, background-image, background-position,  background-repeat, background-size，outline-color, outline-style, outline-width, box-shadow
- ...

**重排的触发场景**

- 删除或者新增一个节点元素
- 元素位置的改变，比如float,position,overflow,display等等
- 元素尺寸的改变，比如margin,padding,height,width等等
- 初始化构建DOM树的时候
- 窗口尺寸的变化 也就是resize事件发生的时候
- 填充内容的改变（内容撑大了某一个节点，内容改变，包含它的节点大小自然跟随调整。）
- 读取某一个元素的时候，比如offsetLeft，offsetTop，offsetHeight，offsetWidth,　clientTop，clientLeft，clientWidth，clientHeight,　scrollTop，scrollLeft，scrollWidth，scrollHeight,　width，height等等
- ...

使用部分CSS属性来优化性能
在 GPU 渲染的过程中，一些元素会因为符合了某些规则，而被提升为独立的层（黄色边框部分），一旦独立出来，就不会影响其它 DOM 的布局，所以我们可以利用这些规则，将经常变换的 DOM 主动提升到独立的层，那么在浏览器的一帧运行中，就可以减少 Layout 和 Paint 的时间了。
哪些规则能让浏览器主动帮我们创建独立的层呢？

1. 3D 或者透视变换（perspective，transform） 的 CSS 属性。
2. 使用加速视频解码的 video 元素。
3. 拥有 3D（WebGL） 上下文或者加速 2D 上下文的 canvas 元素。
4. 混合插件（Flash)。
5. 对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素。
6. 拥有加速 CSS 过滤器的元素。
7. 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)。
8. 元素有一个兄弟元素在复合图层渲染，并且该兄弟元素的 z-index 较小，那这个元素也会被应用到复合图层。
#### 开启 GPU 加速

CSS 中的以下几个属性能触发硬件加速：

1. transform
2. opacity
3. filter
4. will-change


## 使用服务端渲染
如果使用服务端渲染（SSR）的话，首先_首屏加载速度会有显著的提升_（因为SSE只需要加载首页一个页面）。并且_对SEO也很友好_。

当然它也有弊端：页面数据更容易被爬。服务器压力会变大。


## 图片优化
图片压缩tiny-png，或者更换webp格式图片或者avif格式图片

## 使用CDN资源

 ## 使用HTTP2
 



## 合并请求
_为了减少请求时间，为了减小服务器压力_。ajax请求并不是没有成本的。每次请求都需要进行TCP的_三次握手_和_四次挥手，解析报文_等一系列的过程，这些过程都需要时间去执行。并且，浏览器在同一域名下的请求并发数有限制，_同一域名下同一个请求只能并发一个，不同类型请求（比如GET/POST）并发个数基本在4-6个之间_。假设当前浏览器的并发请求有6个。那么第7个请求就需要等前6个请求中任意一个完成以后才可以从任务队列中被拉出去执行。_所以，合并请求可以在一定程度上减少资源响应时间，给用户带来更好的使用体验。_

  合并请求的基本方案

1. 使用精灵图（合并静态图片资源请求）
2. 合理合并get请求,在适当的情况下，我们可以将一些可以合并的get请求合并为一个

## 事件委托
将事件挂载到父元素上面去
_事件委托适用场景：列表数据和瀑布流数据等需要大量绑定相同功能的函数的场景。_

## 使用CSS动画完成动画
一些简单的，需要手动绘制的动画，在CSS可以完成的情况下，_尽量避免使用JS完成动画_。

使用CSS完成动画的好处是：

1. 不占用主线程（js是需要占用的）
2. 可以利用硬件加速
3. 在不可见时动画不会持续执行

## 使用懒加载
对于一些不必要立即显示的节点，我们可以采用懒加载技术。在需要使用到的时候，再去加载该文件（组件），以减少不必要的内存占用和页面负载。

## 使用骨架屏

## absolute脱离文档流优化css性能，这样元素改变就不会大面积的重排了


## webworker（大量数据运算）
webworker是独立的线程，不会与主线程冲突
实现主线程与复杂计运算线程的分离，从而减轻了因大量计算而造成UI阻塞的情况
在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。
[Web Worker 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2018/07/web-worker.html)


## 使用getBoundingClientRect()获取元素位置
`getBoundingClientRect()` 不触发重排（reflow）或重绘（repaint）。它提供的信息是布局阶段的副产品，浏览器在渲染过程中已经计算好并存储了这些数据。  
因此，调用此方法不会直接影响渲染流水线，避免了可能阻塞主线程的操作。


## 回流与重绘
### 回流  
当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。  
  
下面这些操作会导致回流：  
* 页面的首次渲染  
* 浏览器的窗口大小发生变化  
* 元素的内容发生变化  
* 元素的尺寸或者位置发生变化  
* 元素的字体大小发生变化  
* 激活CSS伪类  
* 查询某些属性或者调用某些方法  
* 添加或者删除可见的DOM元素  
  
在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：  
* 全局范围：从根节点开始，对整个渲染树进行重新布局  
* 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局  

### 重绘  
当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。  
  
下面这些操作会导致重绘：  
* color、background 相关属性：background-color、background-image 等  
* outline 相关属性：outline-color、outline-width 、text-decoration  
* border-radius、visibility、box-shadow  
注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。

## 如何避免回流与重绘？
减少回流与重绘的措施：  
* 操作DOM时，尽量在低层级的DOM节点进行操作  
* 不要使用table布局， 一个小的改动可能会使整个table进行重新布局  
* 使用CSS的表达式  
* 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。  
* 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素  
* 避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中  
* 将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。  
* 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。
浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列  
  
浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。  
  
上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

## 如何优化动画
对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的position属性设置为absolute或者fixed，将动画脱离文档流，这样他的回流就不会影响到页面了。

## documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？
MDN中对documentFragment的解释：  
DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。  
  
当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。


# 动画
## JS动画
	* **setTimeout** / **setInterval** / **requestAnimationFrame**
`setTimeout/setInterval` 无法与浏览器每帧绘制保持同步，所以可能会存在卡顿、丢帧、抖动的现象，导致动画体验不如 CSS3 动画。所以才有了 **与浏览器的绘制帧同步** 的原生 API `requestAnimationFrame`，以取代 `setTimeout` 和 `setInterval` 实现动画。

	* **Web Animations API**
## CSS动画
	* **CSS Transition**
CSS 过渡，属于**补间动画**，即设置关键帧的初始状态，然后在另一个关键帧改变这个状态，比如大小、颜色、透明度等，浏览器将自动根据二者之间帧的值创建的动画。无法自动执行。会在元素的属性值发生变化时平滑地过渡到新的值。
```css
  div {
    opacity: 1;
  }
  
  div:hover {
    opacity: 0.5;
    transition: opacity, 3s;
  }
  

```
	* **CSS Animation**
CSS 动画，可以理解是 `CSS Transition` 的加强版，它既可以实现 **补间动画** 的动画效果，也可以使其以 **逐帧动画** 的方式进行绘制。可以自动执行
```css
  @keyframes slidein {
    from {
      transform: translateX(0%);
    }

    to {
      transform: translateX(100%);
    }
  }

  /* 等效于下面 @keyframes 规则的定义 */

  @keyframes slidein {
    0% {
      transform: translateX(0%);
    }

    100% {
      transform: translateX(100%);
    }
  }


```

> css动画都可以通过js事件去监听

用CSS3动画替代JS模拟动画的好处：

1. 不占用JS主线程；
    
2. 可以利用硬件加速；
    
3. 浏览器可对动画做优化（元素不可见时不动画减少对FPS影响）

# 自定义hooks  
组合hooks
实现过的hooks，useKeepScroll
复用逻辑


# option compositon（vue2和vue3的对比） 
## 为什么要有组合式 API？
### 更好的逻辑复用
### 更灵活的代码组织
### TS支持更好
### 更小的生产包体积



# proxy defineProperty对比
Vue3.x改用`Proxy`替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。


## defineProperty
```js
let person = {}
let personName = 'lihua'

//在person对象上添加属性namep,值为personName
Object.defineProperty(person, 'namep', {
    //但是默认是不可枚举的(for in打印打印不出来)，可：enumerable: true
    //默认不可以修改，可：wirtable：true
    //默认不可以删除，可：configurable：true
    get: function () {
        console.log('触发了get方法')
        return personName
    },
    set: function (val) {
        console.log('触发了set方法')
        personName = val
    }
})

//当读取person对象的namp属性时，触发get方法
console.log(person.namep)

//当修改personName时，重新访问person.namep发现修改成功
personName = 'liming'
console.log(person.namep)

// 对person.namep进行修改，触发set方法
person.namep = 'huahua'
console.log(person.namep)

\

```
当监听数组的时候，`push`方法给数组增加的元素，set方法是监听不到的。通过索引访问或者修改数组中已经存在的元素，是可以出发get和set的，但是对于通过push、unshift增加的元素，会增加一个索引，这种情况需要手动初始化，新增加的元素才能被监听到。另外， 通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法。

在Vue2.x中，通过重写Array原型上的方法解决了这个问题

## Proxy
```js
//定义一个需要代理的对象
let person = {
    age: 0,
    school: 'xdu'
}
//定义handler对象
let hander = {
    get(obj, key) {
        console.log('触发了get')
        // 如果对象里有这个属性，就返回属性值，如果没有，就返回默认值66
        return key in obj ? obj[key] : 66
    },
    set(obj, key, val) {
        console.log('触发了set')
        obj[key] = val
        return true
    }
}
//把handler对象传入Proxy
let proxyObj = new Proxy(person, hander)

// 测试get能否拦截成功
console.log(proxyObj.school)//输出：触发了get xdu
console.log(proxyObj.name)//输出：触发了get 66

// 测试set能否拦截成功
proxyObj.age = 18 // 输出：触发了set
console.log(proxyObj.age)//输出： 触发了set 18

```

Proxy代理的是整个对象，而不是对象的某个特定属性，不需要我们通过遍历来逐个进行数据绑定。
值得注意的是:之前我们在使用Object.defineProperty()给对象添加一个属性之后，我们对对象属性的读写操作仍然在对象本身。  
但是一旦使用Proxy，如果想要读写操作生效，我们就要对Proxy的实例对象`proxyObj`进行操作。

在上面使用Object.defineProperty的时候，我们遇到的问题有：

 
1. 一次只能对一个属性进行监听，需要遍历来对所有属性监听。这个我们在上面已经解决了。  
2. 在遇到一个对象的属性还是一个对象的情况下，需要递归监听。  
3. 对于对象的新增属性，需要手动监听  
4. 对于数组通过push、unshift方法增加的元素，也无法监听
数组push会触发两次proxy的set方法，因为会更新数组元素和length属性

# 跨域
跨域问题其实就是浏览器的同源策略所导致的。它用于限制一个[origin](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2F%25E6%25BA%2590 "https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90")的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
协议、域名、端口一致。才能算是同源

为什么需要跨域？
限制不同源的请求
限制DOM操作
> 可以在 http 返回头 添加`X-Frame-Options: SAMEORIGIN` 防止被别人添加至 iframe。

## 解决跨域
跨域资源共享([CORS](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FCORS "https://developer.mozilla.org/zh-CN/docs/Glossary/CORS")) 是一种机制，它使用额外的 [HTTP](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FHTTP "https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP") 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器**「不同的域、协议或端口」**请求一个资源时，资源会发起一个**「跨域 HTTP 请求」**。
CORS中请求会分为简单请求和复杂请求。
### 简单请求
简单请求不会触发 [CORS 预检请求](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FAccess_control_CORS%23Preflighted_requests "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests")
满足
下面条件的请求是简单请求
情况一: 使用以下方法(意思就是以下请求以外的都是非简单请求)

- [`GET`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FGET "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET")
- [`HEAD`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FHEAD "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD")
- [`POST`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FMethods%2FPOST "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST")

情况二: 人为设置以下集合外的请求头

- [`Accept`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept")
- [`Accept-Language`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FAccept-Language "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language")
- [`Content-Language`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Language "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language")
- [`Content-Type`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FHeaders%2FContent-Type "https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type") （需要注意额外的限制）
- `DPR`
- `Downlink`
- `Save-Data`
- `Viewport-Width`
- `Width`

情况三：`Content-Type`的值仅限于下列三者之一：(例如 application/json 为非简单请求)

- `text/plain`
- `multipart/form-data`
- `application/x-www-form-urlencoded`
情况四:

请求中的任意[`XMLHttpRequestUpload`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload "https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload") 对象均没有注册任何事件监听器；[`XMLHttpRequestUpload`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequestUpload "https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestUpload") 对象可以使用 [`XMLHttpRequest.upload`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest%2Fupload "https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/upload") 属性访问。

情况五:

请求中没有使用 [`ReadableStream`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FReadableStream "https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream") 对象。

### 复杂请求

非简单请求的都是复杂请求
如果请求是复杂请求，在发送复杂请求之前，会先发送一个**预请求**，此时作为服务端，也需要返回"预回应"作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。
**预请求以OPTIONS形式发送**，当中同样包含域，并且还包含了两项CORS特有的内容：
> Access-Control-Request-Method – 该项内容是实际请求的种类，可以是GET、POST之类的简单请求，也可以是PUT、DELETE等等。  
Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。

## 解决方法

1.  服务器在响应头加上对应的header
 ```js
 app.use(async (ctx, next) => {  
  ctx.set("Access-Control-Allow-Origin", ctx.headers.origin);  
  ctx.set("Access-Control-Allow-Credentials", true);  
  ctx.set("Access-Control-Request-Method", "PUT,POST,GET,DELETE,OPTIONS");  
  ctx.set(  
    "Access-Control-Allow-Headers",  
    "Origin, X-Requested-With, Content-Type, Accept, cc"  
  );  
  if (ctx.method === "OPTIONS") {  
    ctx.status = 204;  
    return;  
  }  
  await next();  
});
```

这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 `withCredentials` 来进行传递 `cookie`.
```js
// 原生 xml 的设置方式
var xhr = new XMLHttpRequest();xhr.withCredentials = true;// axios 设置方式axios.defaults.withCredentials = true;

```

2. Node正向代理
利用服务端请求不会跨域的特性，让接口和当前站点同域。

3. 配置构建工具的proxy
一般仅限于开发模式中，因为开发才会启动着webpack，vite之类的构建工具，和正向代理一个原理

4. JSONP
`JSONP` 主要就是利用了 `script` 标签没有跨域限制的这个特性来完成的。

**「使用限制」**

仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。

```js
//后端
const Koa = require("koa");
const fs = require("fs");
const app = new Koa();
app.use(async (ctx, next) => {
    if (ctx.path === "/api/jsonp") {
        const { cb, msg } = ctx.query;
        ctx.body = `${cb}(${JSON.stringify({ msg })})`;
        return;
    }
});
app.listen(8080);

```

```html
//前端

<script type="text /javascript">  window.jsonpCallback = function (res) { console.log(res); };</script>
<script  src="http: //localhost:8080/api/jsonp?msg=hello&cb=jsonpCallback"  type="text/javascript"></script>
```

5. websocket
这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制.

6. postMessage
postMessage能忽略跨域进行跨域页面通信
```html
<iframe  src="http: //localhost:8080"  frameborder="0"   id="iframe"   onload="load()"></iframe>
<script>  function load() { iframe.contentWindow.postMessage("秋风的笔记", "http://localhost:8080"); window.onmessage = e => { console.log(e.data); }; }</script>
```

```html
<div>hello</div><script>  window.onmessage = e => {    console.log(e.data); // 秋风的笔记    e.source.postMessage(e.data, e.origin);  };</script>

```
7.  document.domain + Iframe
**「该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式」**。 只需要给页面添加 `document.domain ='test.com'` 表示二级域名都相同就可以实现跨域。
```html
<body>  
  helloa  
  <iframe  
    src="http://b.test.com/b.html"  
    frameborder="0"  
    onload="load()"  
    id="frame"  
  ></iframe>  
  <script>    document.domain = "test.com";  
    function load() {  
      console.log(frame.contentWindow.a);  
    }  </script>  
</body>
```

```html
<body>  
  hellob  
  <script>    document.domain = "test.com";  
    var a = 100;  </script>  
</body>
```


事件机制
# 事件循环
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240828001446.png)
JavaScript的任务分为两种`同步`和`异步`：

- **同步任务：** 在主线程上排队执行的任务，只有一个任务执行完毕，才能执行下一个任务，
- **异步任务：** 不进入主线程，而是放在任务队列中，若有多个异步任务则需要在任务队列中排队等待，任务队列类似于缓冲区，任务下一步会被移到执行栈然后主线程执行调用栈的任务。
在`JavaScript`中，任务被分为两种，一种宏任务（`MacroTask`）也叫`Task`，一种叫微任务（`MicroTask`）。

### MacroTask（宏任务）

- `script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见[`MDN`](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetImmediate "https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate")）、`I/O`、`UI Rendering`。

### MicroTask（微任务）

- `Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver`（具体使用方式查看[这里](https://link.juejin.cn/?target=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fdom%2Fmutationobserver.html "http://javascript.ruanyifeng.com/dom/mutationobserver.html")）
`Javascript` 有一个 `main thread` 主线程和 `call-stack` 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。

### JS调用栈

JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。

### 同步任务和异步任务

`Javascript`单线程任务被分为**同步任务**和**异步任务**，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。


![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240828001926.png)
执行栈在执行完**同步任务**后，查看**执行栈**是否为空，如果执行栈为空，就会去检查**微任务**(`microTask`)队列是否为空，如果为空的话，就执行`Task`（宏任务），否则就一次性执行完所有微任务。  
每次单个**宏任务**执行完毕后，检查**微任务**(`microTask`)队列是否为空，如果不为空的话，会按照**先入先**出的规则全部执行完**微任务**(`microTask`)后，设置**微任务**(`microTask`)队列为`null`，然后再执行**宏任务**，如此循环。



宏任务 微任务

状态管理vuex和piana的区别






vue和react的区别

js动画和css动画 

# requestAnimationFrame
raf在JS代码之后，重绘回流之前执行。
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/Snipaste_2024-08-28_09-29-14.png)

- 使得动画更加流畅，防止动画失帧 requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率
    
- 资源节能(Cpu、内存等)
    
    1. 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量
    2. requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销
应用场景：
* 大数据渲染
* 复杂动画
# requestIdleCallback
requestIdleCallback 会在网页渲染完成后，CPU 空闲时执行，不一定每一帧都执行。

requestIdleCallback 不适合执行 DOM 操作，因为修改了 DOM 之后下一帧不一定会触发修改。
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/Snipaste_2024-08-28_09-29-14.png)
一帧有六个步骤：
- 处理用户的交互
- JS 解析执行
- 帧开始。窗口尺寸变更，页面滚动等的处理
- requestAnimationFrame(rAF)
- 布局
- 绘制

> 上面的步骤执行完之后如果还有空余的时间，会去执行requestIdleCallback里注册的任务。
> 如果是60hz的屏幕就是16.66ms     1000/60 。每帧16.66ms的时间

requestIdleCallback 可用于一些低优先级的场景，以代替 setTimeout 。例如发送统计数据。
  **Promise 也不建议在这里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 `requestIdleCallback` 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。**
  



缓存

回流重会 渲染机制？

防抖节流

虚拟DOM优缺点

# 页面生命周期
- `DOMContentLoaded` —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 `<img>` 和样式表之类的外部资源可能尚未加载完成。
- `load` —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。
- `beforeunload/unload` —— 当用户正在离开页面时。





# HTTP1-2 性能优化
？？

# Observer API

## IntersectionObserver
**IntersectionObserver 可以监听一个元素和可视区域相交部分的比例，然后在可视比例达到某个阈值的时候触发回调。**


## MutationObserver
**MutationObserver 可以监听对元素的属性的修改、对它的子节点的增删改。**


## ResizeObserver
窗口我们可以用 addEventListener 监听 resize 事件，那元素呢？

**元素可以用 ResizeObserver 监听大小的改变，当 width、height 被修改时会触发回调。**



## PerformanceObserver
浏览器提供了 performance 的 api 用于记录一些时间点、某个时间段、资源加载的耗时等。

我们希望记录了 performance 那就马上上报，可是怎么知道啥时候会记录 performance 数据呢？

用 PeformanceObserver。

  
## ReportingObserver

**ReportingObserver 可以监听过时的 api、浏览器干预等报告等的打印，在回调里上报，这些是错误监听无法监听到但对了解网页运行情况很有用的数据。**


监听用户的交互行为，我们会用 addEventListener 来监听 click、mousedown、keydown、input 等事件，但对于元素的变化、performance 的记录、浏览器干预行为这些不是用户交互的事件就要用 XxxObserver 的 api 了。

浏览器提供了这 5 种 Observer：

- IntersectionObserver：监听元素可见性变化，常用来做元素显示的数据采集、图片的懒加载
- MutationObserver：监听元素属性和子节点变化，比如可以用来做去不掉的水印
- ResizeObserver：监听元素大小变化

还有两个与元素无关的：

- PerformanceObserver：监听 performance 记录的行为，来上报数据
- ReportingObserver：监听过时的 api、浏览器的一些干预行为的报告，可以让我们更全面的了解网页 app 的运行情况

这些 api 相比 addEventListener 添加的交互事件来说用的比较少，但是在特定场景下都是很有用的。

  

作者：zxg_神说要有光  
链接：https://juejin.cn/post/7064557881492209678  
来源：稀土掘金  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。






# 闭包
当一个内部函数可以访问其外部函数的变量时，便形成了闭包
闭包的实现，实际上是利用了`JavaScript`中作用域链的概念，简单理解就是：在`JavaScript`中，如果在某个作用域下访问某个变量的时候，如果不存在，就一直向外层寻找，直到在全局作用域下找到对应的变量为止，这里就形成了所谓的作用域链。

## 闭包的特性

1. 闭包可以访问到父级函数的变量
2. 访问到父级函数的变量不会销毁
## 作用
- **实现共有变量**：在模块化开发中，闭包可以用来创建私有变量并暴露有限的公共接口，实现数据的封装和隔离。
- **做缓存**：利用闭包可以存储计算结果，避免重复计算，提高程序效率。
- **封装模块，防止全局变量污染**：通过闭包封装变量和函数，可以有效减少全局作用域的污染，保持代码的整洁和可维护性。

  
## 缺点
内容可能得不到释放，引发内存泄漏
# this

# vite相关面试题
`vite`开发环境依赖`esbuild`进行预构建，生产环境则依赖`rollup`进行打包，并且充分利用了现代浏览器的特性，比如`http2`、`ES module`，`vite`是站在众多巨人肩膀上的一个产物， 类似`webpack + webpack-dev-server`的结合体，是一个非常棒的前端项目的构建工具。

  绝大多数现代浏览器都已经支持`ES module`了， 我们只需要在`<script>`标签中添加`type="module"`，就可以使用`ES module`了。
在`<script type="module">`中，浏览器遇到内部的import引用时，会自动发起http请求，去加载对应的模块。

vite也正是利用了`ES module`这个特性，使用vite运行项目时，首先会用`esbuild`进行预构建，将所有模块转换为`es module`，不需要对我们整个项目进行编译打包，而是在浏览器需要加载某个模块时，拦截浏览器发出的请求，根据请求进行`按需编译`，然后返回给浏览器。
esbuild使用的是go语言编写的，可以充分利用多核CPU的优势，所以vite开发环境下的`预构建`与`按需编译`速度，都是非常快的
。

## http2
  vite充分利用了http2可以并发请求的优势，这也是速度快的一个主要原因。 接下来，我们了解一下**http2**的来龙去脉。

在之前http1的时候，浏览器对同一个域名的请求，是有并发限制的，一般为6个，如果并发请求6个以上，就会造成阻塞问题，所以在http1的时代，我们要减少打包产物的文件数量，减少并发请求，来提高项目的加载速度。

2015年以后，http2出现了，他可以并发发送多个请求，不会出现http1的并发限制。这时候，将打包产物分成多个小模块，并行去加载，反而会更快。

vite也充分利用了这一优势，对项目资源进行了合理的拆分，访问项目时，同时加载多个模块，来提升项目访问速度。

  
webpack热更新会重新打包项目，即使有缓存机制，也还是长时间
vite项目中，监听到文件变更后，会用`websocket`通知浏览器，重新发起新的请求，只对该模块进行重新编译，然后进行替换。

并且基于`es module`的特性，vite利用浏览器的缓存策略，针对源码模块（我们自己写的代码）做了`协商缓存`处理，针对依赖模块（第三方库）做了`强缓存`处理，这样我们项目的访问的速度也就更快了。

## 生产环境

Rollup 是一款 `ES Module` 打包器， 从作用上来看，`Rollup` 与 `Webpack` 非常类似。不过相比于 `Webpack`，`Rollup`要小巧的多，打包生成的文件更小。 因为小巧，自然在这种特定的打包环境下，`Rollup`的打包速度也要比 `Webpack` 快很多。

vite正是基于`es module`的特性实现的，所以使用rollup要更合适一些。

**vite生产环境下，为什么不用esbuild打包呢？**

尽管esbuild的打包速度比rollup更快，但 Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容，rollup插件api与基础建设更加完善，所以在生产环境vite使用rollup打包会更稳定一些。

如果后面esbuild基础建设与生态更加完善后，esbuild还是更有优势的。

所以使用vite可能会带来开发环境与生产环境打包结果不一致的问题。


webpack很多东西要自己搭建，比如：`跨域`、`代码压缩`、`代码分割`、`css预处理器的代码转换`、`样式兼容性`、`vue/react代码解析`、`图片压缩`、`代码热更新`、`es降级`、`ts转换`等等。vite对这些常用功能都做了内置支持。




# CMS
背景：每次运营有活动都需要开发去开发新的页面

## PDF文件生成

# SEO优化

使用语义化标签
在页面大小标题和文案中重复关键词，以达到内容强化目的；关键词汇避免使用图片，便于爬虫检索，收录。
img 添加 alt 属性，用 h1 标签去写内容关键字

meta标签

**A. Keywords(关键词，很重要)**  
说明：规定一个逗号分隔的关键词列表（告诉搜索引擎页面是与什么相关的）。


`例如：<meta name="keywords" content="掘金,稀土,Vue.js,前端面试题,Kotlin,ReactNative,Python">`

**B. description(网站内容描述，很重要)**  
说明：规定页面的描述。搜索引擎会把这个描述显示在搜索结果中。

`例如：<meta name="description" content="掘金是面向全球中文开发者的技术内容分享与交流平台。我们通过技术文章、沸点、课程、直播等产品和服务，打造一个激发开发者创作灵感，激励开发者沉淀分享，陪伴开发者成长的综合类技术社区。">`

**C. author**  
说明：作者的名字


`例如：<meta name="author" content="Hege Refsnes">`

**D. generator**  
说明：代表说明网站的采用的什么软件制作。


`例如：<meta name="generator" content="Hege Refsnes">`

**E. theme-color**  
说明：代表页面显示设计的建议颜色。


`例如：<meta name="theme-color" content="#4285f4" />`

**1.2 http- equiv**

http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容。  
meta标签的http-equiv属性语法格式是： `<meta http-equiv="参数"content="参数变量值">；`  
其中http-equiv属性主要有以下几种参数：

## 确保页面性能

## sitemap站点地图
## 使用HTTPS

# es6 和后面新的api

[ES6 完全使用手册此外还要注意这里不一定就是正式进入规范的语法。 1. let 和 const 在我们开发的时候，可能 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903726201700365?searchId=2024082815002430731E303B990D645B53)

[2.8万字总结！！ES6到ES12常用新特性！ES是ECMAScript的缩写，也就是JavaScript的标准化规范。 - 掘金 (juejin.cn)](https://juejin.cn/post/7272176270808137783#heading-32)



# 网络
## TCP
### 流量控制
### 拥塞控制
目的就是**避免「发送方」的数据填满整个网络。**
为了在「发送方」调节所要发送数据的量，定义了一个叫做「**拥塞窗口**」的概念。
**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。
发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。
拥塞窗口`cwnd`变化的规则：
* 只要网络中没有出现拥塞，cwnd就增大
* 如果网络中出现了拥塞，cwnd就减小
> 那么怎么知道当前网络是否出现了拥塞呢？


只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞。**
拥塞控制主要是四个算法：
* 慢启动
* 拥塞避免
* 拥塞发生
* 快速恢复
#### 慢启动
**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829232227.png)
有一个叫慢启动门限 `ssthresh` （slow start threshold）状态变量。
- 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
- 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」。
#### 拥塞避免
当拥塞窗口 `cwnd` 「超过」慢启动门限 `ssthresh` 就会进入拥塞避免算法。
一般来说 `ssthresh` 的大小是 `65535` 字节。
那么进入拥塞避免算法后，它的规则是：**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**
接上前面的慢启动的栗子，现假定 `ssthresh` 为 `8`：
当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 `MSS` 大小的数据，变成了**线性增长。**
![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829233322.png)
拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。当触发了重传机制，也就进入了「拥塞发生算法」。

#### 拥塞发生
当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：
- 超时重传
- 快速重传

> 当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：
- `ssthresh` 设为 `cwnd/2`，
- `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）

![](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829233620.png)

>  发生快速重传的拥塞发生算法

还有更好的方式，前面我们讲过「快速重传算法」。还有更好的方式，前面我们讲过「快速重传算法」。TCP 认为这种情况不严重，因为大部分没丢只丢了一小部分，则 `ssthresh` 和 `cwnd` 变化如下：
- `cwnd = cwnd/2` ，也就是设置为原来的一半;
- `ssthresh = cwnd`;
- 进入快速恢复算法

#### 快速恢复
快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 `RTO` 超时那么强烈。
正如前面所说，进入快速恢复之前，`cwnd` 和 `ssthresh` 已被更新了：
- `cwnd = cwnd/2` ，也就是设置为原来的一半;
- `ssthresh = cwnd`;
然后，进入快速恢复算法如下：
- 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的 ACK，那么 cwnd 增加 1；
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

![image.png](https://raw.githubusercontent.com/StoryKing123/pics/main/20240829234012.png)


# 介绍项目+项目难点亮点+怎么解决

## 电子保卡
背景：在过去，患者在做了植入器械之后，厂商会出具实体保卡给患者，供患者去医院随访的时候出示，走线下流程就代表着可能会丢失保卡或者邮寄时间过长。这个系统是用来取代线下的流程，患者直接在微信公众号注册登记信息之后，后台会进行匹配，匹配成功之后，就会去发放电子保卡。患者就可以在公众号端看到自己的电子保卡。

### 组件保留滚动
难点：平常我们使用KeepAlive标签去在页面切换的时候保留上一个页面组件。包括滚动进度。但是如果滚动条不是在页面上，而是在某一个元素上面，KeepAlive就无法做到保留元素的滚动进度。

解决方法：通过查阅资料可以自己通过hooks实现
主要利用生命周期函数deactivated和activated。在deactivated中把元素的滚动位置记录下来，在activated中还原元素的滚动位置。把这两个生命周期函数抽成hooks。这样就可以在需要使用的组件里面去引入。

### 数据迁移
难点：
* 数据源来自多方
* 表结构改动过大
* 数据量大
#### 解决方法




## 代收缴费用系统
一个用来代替第三方公司去缴纳水电费用的系统。主要是和其他银行系统进行交互。因为系统老旧，所以没有通过http请求，都是通过txt文件上传下载去进行系统交互。这个系统主要就是各种的txt文件和PDF文件生成。PDF文件用来内部使用签名之类的，txt文件用来和其他系统交互。

难点：
应用是一个低代码应用，但是文件的生成是通过JS去实现的， 通过JS去开发一个生成PDF文件的组件，然后在应用中使用。主要技术是用HTMLtoCanvas，然后CanvasToPDF。主要遇到了两个难点。
生成的PDF会有文字重叠的情况：
因为低代码应用为了适应在任何分辨率和高宽的场景下，都保持同样的布局，所以使用了transform进行缩放。生成文件所用的PDF也在transform的影响之内，所以导致生成的PDF会文字重叠。
解决方法：把HTML元素移除到transform的元素之外。

在一个PDF里面生成了太多页导致报错，输入长度超过限制
通过pnpm patch去改源码库，使用arraybuffer替代string传入解决长度限制
[Fix Invalid String Length When Saving PDF #1724 by shiina-mash1ro · Pull Request #3625 · parallax/jsPDF (github.com)](https://github.com/parallax/jsPDF/pull/3625)

###  文字重叠
因为把节点渲染在受transform影响的节点之内导致的
解决：通过查阅资料之后，发现需要把节点挂载到transform节点之外，比如body旁边


# CMS
运营部门每隔一段时间需要出活动页，活动页基本上都是一样的东西，只是图案文本等元素不对。每次都要开发去重新修改代码去适配太过麻烦。所以开发出了一套CMS去给运营使用，运营只需要去配置文本，图片等素材，即可创建新的活动网页。

难点：服务端读取配置内容后渲染页面后生成对应的HTML文件。在不使用SSR的情况下，进行服务端渲染。查阅文档之后发现Vite有一个SSG的支持。基于此支持开发出了CMS内容。自己实现了useClient或者useServer之类的hook，可以分别在客户端和服务端上运行对应的函数hooks。