react中一切更新都是通过update去创建。
React中有许多触发状态更新的方法
* ReactDOM.createRoot
* this.setState
* this.forceUpdate
* useState dispatcher
* useReducer dispatcher
虽然这些方法的执行场景不同，但是都可以接入同样的更新流程，因为他们都是使用Update数据结构代表更新。



![[update的产生与消费.excalidraw]]

对于FC，Update数据结构如下，其中包含了lane字段，这就建立了lane与update的联系。

```typescript

const update = {
	lane, //对应lane
	action, //改变state方法
	hasEagerState:false, //性能优化相关字段
	next:null //与其他update连接形成环状链表
}

```

在render阶段beginWork中，基于“workInProgressRootRenderLanes”中包含的lane，选择fiberNode中包含对应的lane的update，并基于这些update计算出state。
基于state计算出UI变化，以subtreeFlags的形式保存。最终在commit阶段，基于subtreeFlags将变化渲染到UI中。

## 高优先级Update可以打断低优先级Update
高优先级update会中断正在进行中的低优先级update，先完成更新流程。待完成后，低优先级update基于高优先级update计算出的staet重新完成更新流程。
ClassComponent与HostRoot所使用的Update结构如下：
``
```typescript
  

export function createUpdate(lane: Lane): Update<mixed> {

const update: Update<mixed> = {

lane,

  

tag: UpdateState,

payload: null,

callback: null,

  

next: null,

};

return update;

}
```

FC 所用的update如下
```typescript
const udpate = {
	lane,
	action,
	hasEagerStaet:false,//优化策略相关字段
	eagerStaet:null,
	next:null
}
```

>payload代表承载
>lane代表紧急程度
>next代表update之前的顺序,next指向下一个update



# updateQueue
update是计算state的最小单位，updateQueue是保存参与state计算的相关数据的数据结构，updateQueue在不同类型的fiberNode中也有不同的数据结构。
```typescript
const updateQueue = {
	baseState: null, //参与计算的初始state
	firstBaseUpdate: null, //本次更新该fiberNode中已保存的update，其中的链表头update
	lastBaseUpdate: null, //链表尾update
	shared: {
		pending: null //触发更新后，产生的update会保存在shared.pending中形成单向环状链表。计算state时，该环状链表会拆分并拼接在lastBaseUpdate后面
	}
}
```

state计算的流程可以简单概括为两步：
1. 将baseUpdate 与 share.pending 拼接成新链表
2. 遍历拼接后的新链表，根据workInProgressRootRenderLanes选定的优先级，基于“符合优先级条件的update” 计算state





非工作流程内产生的update为分析对象。由于schedule阶段的存在，update产生后可能并不会立刻被消费，因此当fiberNode中产生update时，有下面两种情况
* 当前fiberNode 中不存在未被消费的update，则该update会与自身形成环状链表
* 当前fiberNode中存在未被消费的update组成的环状链表，则将新update插入该链表中

```typescript
const pending = sharedQueue.pending;

if (pending === null) {

// This is the first update. Create a circular list.

update.next = update;

} else {

update.next = pending.next;

pending.next = update;

}

sharedQueue.pending = update;
```

假设某fiberNode中产生u0、u1、u2、u3四个update，且中途都未被消费，则插入u0后情况如下面
```typescript
//pending === null 时

u0.next = u0;
shared.pending = u0;
```

![[update插入.excalidraw]]