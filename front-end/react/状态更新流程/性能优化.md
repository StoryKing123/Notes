React作为一款重运行时框架，拥有多个与性能优化相关的API。
* shouldComponentUpdate
* PureComponent
* React.memo
* useMemo
* useCallback
这些API是因为React无法像Vue一样在编译时做出优化，因此这部分工作放在运行时交由开发者完成。事实上，React内部由完整的运行时性能优化策略。开发者调用性能优化API的本质，就是命中上述策略。从开发者的角度开发，React性能优化有两个方向：
1. 便携符合性能优化策略的组建，命中策略
2. 调用性能优化API，命中策略

介绍性能优化策略的实现
```jsx
export default function App() {
  const [num, updateNum] = useState(0);
  console.log("App render", num);

  return (
    <div className="App">
      <div onClick={() => updateNum(1)}>
        <Child />
      </div>
    </div>
  );
}

function Child() {
  console.log("child render");
  return <span>child</span>;
}

```
点击三次DIV之后，会打印如下
```
App render 0
child render

App render 1
child render

App render1
```

后续点击DIV时不会打印。

第二次点击并未打印child render，这是一种发生于render阶段的优化策略，被称为bailout。命中该策略的组建的子组建会跳过reconcile流程，即子组件不会进入render阶段。
再观察后续不会打印，这是因为App、Child并未进入render阶段，这是一种发生于触发状态更新时的优化策略，被称为eagerState。命中该策略的更新不会进入schedule阶段，也不会进入render阶段。

# eagerState策略
eagerState策略的逻辑很简单：如果某个状态更新前后没有状态变化，则可以跳过后续更新流程。在上面例子中，后续点击不会打印，是因为即使updateNum(1)反复执行，num更新前后都是1，没有变化，所有后续流程被跳过。
state是基于update计算而来，计算过程发生在render阶段的beginWork中。eagerState表示：在当前fiberNode不存在待执行的更新的情况下，可以将这一计算过程提前到schedule阶段之前执行。策略的前提条件之所以是“当前fiberNode不存在待执行的更新”，是因为这种情况下触发更新，产生的update时当前fiberNode中第一个待执行的更新，计算state时不会收到其他update的影响。

对于useState触发的更新，以上逻辑发生于dispatchSetstate方法，具体代码如下。

```typescript
//链表中插入update
    const alternate = fiber.alternate;
	//判断current、wip的lanes是否为Nolanes
    if (
      fiber.lanes === NoLanes &&
      (alternate === null || alternate.lanes === NoLanes)
    ) {

      //eagerState优化策略
      // The queue is currently empty, which means we can eagerly compute the
      // next state before entering the render phase. If the new state is the
      // same as the current state, we may be able to bail out entirely.
      //上次计算时使用的reducer
      const lastRenderedReducer = queue.lastRenderedReducer;
      if (lastRenderedReducer !== null) {
        let prevDispatcher;
        try {
		  //即memoizedState
          const currentState: S = (queue.lastRenderedState: any);
          //基于action提前计算state
          const eagerState = lastRenderedReducer(currentState, action);
          // Stash the eagerly computed state, and the reducer used to compute
          // it, on the update object. If the reducer hasn't changed by the
          // time we enter the render phase, then the eager state can be used
          // without calling the reducer again.
          //标记该update存在eagerState
          update.hasEagerState = true;
          update.eagerState = eagerState;
          if (is(eagerState, currentState)) {
		    // state不变时，返回
            // Fast path. We can bail out without scheduling React to re-render.
            // It's still possible that we'll need to rebase this update later,
            // if the component re-renders for a different reason and by that
            // time the reducer has changed.
            // TODO: Do we still need to entangle transitions in this case?
            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);
            return;
          }
        } catch (error) {
          // Suppress the error. It will throw again in the render phase.
        } finally {
        }
      }
    }

```

判断current、wip的lanes是否为NoLanes，即判断当前fiberNode是否存在‘待执行的更新’。若不存在，则尝试基于“本次更新对应action”计算eagerState。对于useState来说，lastRenderedReducer为如下函数：
```javascript

function basicStateReducer(state,action){
	return typeof action === 'function'? action(state) : action;
}

```

对于useReducer来说，lastRenderedReducer为开发者编写的reducer。
如果 Object.is(eagerState,memoizedState) 为 true，代表state没有变化，命中eagerState Celt，不会进入schedule阶段。即使不为true ，由于这是当前fiberNode中第一个待执行的更新，在它之前不会有其他 update 影响它的计算结果。因此可以将eagerState保存下来。在beginWork中计算state时，对于该update，可以直接使用“保存的eagerState”，不需要再基于update.action计算。这就是FC所使用的Update数据结构中如下字段的意义
```javascript
const update = {
	//是否是eagerState
	hasEagerState: false
	//eagerState的计算结果
	eagerState: null
	...
}
```
观察第二次点击，即使更新前后num都为1，还是执行了后续更新流程（打印 "App render 1"）。为什么这种情况没有命中eagerState策略？


```javascript
const dispatch = queue.dispatch = dispatchSetState.bind(
	null,
	//App对应的fiberNode
	currentlyRenderingFiber,
	//updateQueue
	queue
)
```
fiberNode分为current、wip两种，这里传入的参数是wip。root.pendingLanes工作流程包含如下步骤：
1. 更新fiberNode.lanes（同时更新wip与current）
2. 重置fiberNode.lanes （重置wip.lanes）
可见，对于一次更新，当begwinWork更新前，current.lane、wip.lanes都不是NoLanes，因为上述步骤1会更新lanes。当beginWork执行后，wip.lanes被重置为NoLanes。进入commit阶段后，wip 与 current 互换。根据eagerState的判断逻辑，wip与current需要同时满足条件，这就是第二个没有命中eagerState策略的原因。

```javascript
if (
      fiber.lanes === NoLanes &&
      (alternate === null || alternate.lanes === NoLanes)
    ) {
	...
}
```

虽然第二次点击没有命中eagerState策略，但是第二次点击没有打印"child render"，代表命中了bailout策略。对于命中该策略的FC，会执行bailoutHooks方法

```typescript

export function bailoutHooks(
  current: Fiber,
  workInProgress: Fiber,
  lanes: Lanes,
): void {
  workInProgress.updateQueue = current.updateQueue;
  // TODO: Don't need to reset the flags here, because they're reset in the
  // complete phase (bubbleProperties).

  workInProgress.flags &= ~(PassiveEffect | UpdateEffect);
  //从current.lanes中移除
  current.lanes = removeLanes(current.lanes, lanes);
}

```

最后一行代码会从current.lanes 中移除 rednerLanes。所以对于第二次点击，当一轮更新流程结束后，wip.laens与current.lanes均为NoLanes。在这种情况下，后续点击会命中eagerState策略，不会进入schedule阶段，fiberNode.lanes 不会更新。

___

# bailout策略
beginWork的目的是生成wip fiberNode的子fiberNode,实现这个目的存在两条路径：
1. 通过reconciler流程生成子fiberNode
2. 通过bailout策略服用子fiberNode

命中bailout策略表示子fiberNode没有变化，可以复用。“变化”是由自变量改变造成的，React中的自变量包括：
1. state  
2. props  
3. context
所以，是否命中bailout策略主要围绕以上三个变量展开。bailout策略工作流程如下图所示
进入beginWork后，有两次与“是否命中bailout策略”相关的判断，第一次发生在刚进入beginWork时。具体到代码层面--同时满足以下条件后命中bailout策略
1. oldProps === newProps
props比较时全等比较。组件render后会返回JSX，JSX时createElement方法的语法糖。所以render返回的结果时createElement方法的执行结果，即一个包含props属性的对象。即使本次更新与上次更新过程中，pros的每一项属性都没有变化，但是本次更新是createElement方法的执行结果，是一个全新的props引用，所以oldProps与newProps并不全等。只有当父 fiberNode命中 bailout策略，复用子fiberNode，在子fiberNode的beginWork中，oldPorps才会与newProps全等。

![[bailout策略.excalidraw|675]]

2. Legacy Context（旧Context API没有变化）
3. fiberNode.type没有变化（比如没有从DIV变为UL，）
在组件内定义组件，由于Parent每次render后都会创建新的Child引用，因此对于Child来说，fiberNode.type始终是变化的，无法命中bailout策略。
1. 当前fiberNode没有更新发生
没有更新发生意味着没有state变化，（有更新发生也不意味着state一定会发生变化）