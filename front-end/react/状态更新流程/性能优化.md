React作为一款重运行时框架，拥有多个与性能优化相关的API。
* shouldComponentUpdate
* PureComponent
* React.memo
* useMemo
* useCallback
这些API是因为React无法像Vue一样在编译时做出优化，因此这部分工作放在运行时交由开发者完成。事实上，React内部由完整的运行时性能优化策略。开发者调用性能优化API的本质，就是命中上述策略。从开发者的角度开发，React性能优化有两个方向：
1. 便携符合性能优化策略的组建，命中策略
2. 调用性能优化API，命中策略

介绍性能优化策略的实现
```jsx
export default function App() {
  const [num, updateNum] = useState(0);
  console.log("App render", num);

  return (
    <div className="App">
      <div onClick={() => updateNum(1)}>
        <Child />
      </div>
    </div>
  );
}

function Child() {
  console.log("child render");
  return <span>child</span>;
}

```
点击三次DIV之后，会打印如下
```
App render 0
child render

App render 1
child render

App render1
```

后续点击DIV时不会打印。

第二次点击并未打印child render，这是一种发生于render阶段的优化策略，被称为bailout。命中该策略的组建的子组建会跳过reconcile流程，即子组件不会进入render阶段。
再观察后续不会打印，这是因为App、Child并未进入render阶段，这是一种发生于触发状态更新时的优化策略，被称为eagerState。命中该策略的更新不会进入schedule阶段，也不会进入render阶段。

# eagerState策略
eagerState策略的逻辑很简单：如果某个状态更新前后没有状态变化，则可以跳过后续更新流程。在上面例子中，后续点击不会打印，是因为即使updateNum(1)反复执行，num更新前后都是1，没有变化，所有后续流程被跳过。
state是基于update计算而来，计算过程发生在render阶段的beginWork中。eagerState表示：在当前fiberNode不存在待执行的更新的情况下，可以将这一计算过程提前到schedule阶段之前执行。策略的前提条件之所以是“当前fiberNode不存在待执行的更新”，是因为这种情况下触发更新，产生的update时当前fiberNode中第一个待执行的更新，计算state时不会收到其他update的影响。

对于useState触发的更新，以上逻辑发生于dispatchSetstate方法，具体代码如下。

```typescript
//链表中插入update
    const alternate = fiber.alternate;
	//判断current、wip的lanes是否为Nolanes
    if (
      fiber.lanes === NoLanes &&
      (alternate === null || alternate.lanes === NoLanes)
    ) {

      //eagerState优化策略
      // The queue is currently empty, which means we can eagerly compute the
      // next state before entering the render phase. If the new state is the
      // same as the current state, we may be able to bail out entirely.
      //上次计算时使用的reducer
      const lastRenderedReducer = queue.lastRenderedReducer;
      if (lastRenderedReducer !== null) {
        let prevDispatcher;
        try {
		  //即memoizedState
          const currentState: S = (queue.lastRenderedState: any);
          //基于action提前计算state
          const eagerState = lastRenderedReducer(currentState, action);
          // Stash the eagerly computed state, and the reducer used to compute
          // it, on the update object. If the reducer hasn't changed by the
          // time we enter the render phase, then the eager state can be used
          // without calling the reducer again.
          //标记该update存在eagerState
          update.hasEagerState = true;
          update.eagerState = eagerState;
          if (is(eagerState, currentState)) {
		    // state不变时，返回
            // Fast path. We can bail out without scheduling React to re-render.
            // It's still possible that we'll need to rebase this update later,
            // if the component re-renders for a different reason and by that
            // time the reducer has changed.
            // TODO: Do we still need to entangle transitions in this case?
            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);
            return;
          }
        } catch (error) {
          // Suppress the error. It will throw again in the render phase.
        } finally {
        }
      }
    }

```

判断current、wip的lanes是否为NoLanes，即判断当前fiberNode是否存在‘待执行的更新’。若不存在，则尝试基于“本次更新对应action”计算eagerState。对于useState来说，lastRenderedReducer为如下函数：
```javascript

function basicStateReducer(state,action){
	return typeof action === 'function'? action(state) : action;
}

```

对于useReducer来说，lastRenderedReducer为开发者编写的reducer。
如果 Object.is(eagerState,memoizedState) 为 true，代表state没有变化，命中eagerState Celt，不会进入schedule阶段。即使不为true ，由于这是当前fiberNode中第一个待执行的更新，在它之前不会有其他 update 影响它的计算结果。